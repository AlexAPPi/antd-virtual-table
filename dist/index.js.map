{"version":3,"file":"index.js","sources":["../src/src/dom-helpers.ts","../src/src/helpers.ts","../node_modules/fast-deep-equal/index.js","../src/src/cell.tsx","../src/src/grid-helpers.ts","../node_modules/@babel/runtime/helpers/esm/extends.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/memoize-one/dist/memoize-one.esm.js","../node_modules/react-window/dist/index.esm.js","../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","../src/src/grid.tsx","../src/src/table.tsx"],"sourcesContent":["let size: number = -1;\r\n\r\n// This utility copied from \"dom-helpers\" package.\r\nexport function getScrollbarSize(recalculate: boolean = false): number {\r\n\r\n    if (size === -1 || recalculate) {\r\n\r\n        const div = document.createElement('div');\r\n        const style = div.style;\r\n\r\n        style.width = '50px';\r\n        style.height = '50px';\r\n        style.overflow = 'scroll';\r\n  \r\n        document.body.appendChild(div);\r\n  \r\n        size = div.offsetWidth - div.clientWidth;\r\n  \r\n        document.body.removeChild(div);\r\n    }\r\n  \r\n    return size;\r\n}\r\n\r\nexport type RTLOffsetType =\r\n  | 'negative'\r\n  | 'positive-descending'\r\n  | 'positive-ascending';\r\n\r\nlet cachedRTLResult: RTLOffsetType | null = null;\r\n\r\n// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\r\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\r\n// The safest way to check this is to intentionally set a negative offset,\r\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\r\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\r\nexport function getRTLOffsetType(recalculate: boolean = false): RTLOffsetType {\r\n\r\n    if (cachedRTLResult === null || recalculate) {\r\n        const outerDiv = document.createElement('div');\r\n        const outerStyle = outerDiv.style;\r\n        outerStyle.width = '50px';\r\n        outerStyle.height = '50px';\r\n        outerStyle.overflow = 'scroll';\r\n        outerStyle.direction = 'rtl';\r\n\r\n        const innerDiv = document.createElement('div');\r\n        const innerStyle = innerDiv.style;\r\n        innerStyle.width = '100px';\r\n        innerStyle.height = '100px';\r\n\r\n        outerDiv.appendChild(innerDiv);\r\n\r\n        document.body.appendChild(outerDiv);\r\n\r\n        if (outerDiv.scrollLeft > 0) {\r\n            cachedRTLResult = 'positive-descending';\r\n        } else {\r\n            outerDiv.scrollLeft = 1;\r\n            if (outerDiv.scrollLeft === 0) {\r\n                cachedRTLResult = 'negative';\r\n            } else {\r\n                cachedRTLResult = 'positive-ascending';\r\n            }\r\n        }\r\n\r\n        document.body.removeChild(outerDiv);\r\n\r\n        return cachedRTLResult;\r\n    }\r\n\r\n    return cachedRTLResult;\r\n}","export type ValueGetter<T = number> = T | ((index: number) => T);\r\n\r\nexport function isFunction(value: any): value is Function {\r\n    return typeof value === 'function'\r\n        || (value && {}.toString.call(value) === '[object Function]');\r\n}\r\n\r\nexport function isArray<T>(value: T[]): value is T[]\r\nexport function isArray<T>(value: Array<T>): value is Array<T>\r\nexport function isArray<T>(value: T | T[]): value is Array<T>\r\nexport function isArray<T>(value: Readonly<T[]>): value is Readonly<T[]>\r\nexport function isArray<T>(value: Readonly<Array<T>>): value is Readonly<Array<T>>\r\nexport function isArray<T>(value: T | Readonly<T[]>): value is Readonly<Array<T>>\r\nexport function isArray(value: unknown): value is Array<unknown>\r\nexport function isArray(value: unknown): value is Array<unknown> {\r\n    return Array.isArray(value);\r\n}\r\n\r\nexport function sumColumnWidths(columnWidthGetter: ValueGetter<number>, index: number) {\r\n\r\n    if (index < 0) {\r\n        return 0;\r\n    }\r\n\r\n    if(isFunction(columnWidthGetter)) {\r\n        let sum = 0;\r\n        while (index-- > 0) {\r\n            sum += columnWidthGetter(index);\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    return columnWidthGetter + (index * columnWidthGetter);\r\n}\r\n\r\n\r\nexport function sumRowsHeights<T>(rowHeightGetter: ValueGetter<number>, rows: ReadonlyArray<T>, index: number) {\r\n\r\n    if (index < 0) {\r\n        return 0;\r\n    }\r\n\r\n    if(isFunction(rowHeightGetter)) {\r\n\r\n        let sum = 0;\r\n        \r\n        for(; index > -1; index--) {\r\n            sum += rowHeightGetter(index);\r\n        }\r\n\r\n        return sum;\r\n    }\r\n    \r\n    return index * rowHeightGetter;\r\n}\r\n\r\nexport function assignRef<T>(refValue: T, ...refs: (React.Ref<T> | undefined)[]) {\r\n\r\n    for(let i = 0; i < refs.length; i++) {\r\n\r\n        const tmpRef = refs[i];\r\n\r\n        if(typeof tmpRef === 'function') { tmpRef(refValue); }\r\n        if(typeof tmpRef === 'object')   { (tmpRef as unknown as React.MutableRefObject<T>).current = refValue; }\r\n    }\r\n}\r\n\r\nexport function refSetter<T>(...refs: (React.Ref<T> | undefined)[]) {\r\n    return (ref: T) => assignRef(ref, ...refs);\r\n}\r\n\r\nexport function mixClassNameSingle(classList1: string, classList2: string | undefined) {\r\n    return classList1 + (classList2 ? \" \" + classList2 : '');\r\n}\r\n\r\nexport const hasOwn = {}.hasOwnProperty;\r\n\r\nexport type ClassNamesValue = string | number | boolean | undefined | null;\r\nexport type ClassNamesMapping = Record<string, unknown>;\r\nexport type ClassNamesArgument = ClassNamesValue | ClassNamesMapping | ClassNamesArgumentArray;\r\nexport interface ClassNamesArgumentArray extends Array<ClassNamesArgument> {}\r\n\r\nexport function classNames(...args: ClassNamesArgumentArray) {\r\n\r\n    const classes: string[] = [];\r\n\r\n    for (let i = 0; i < arguments.length; i++) {\r\n\r\n        const arg = arguments[i];\r\n\r\n        if (!arg) continue;\r\n\r\n        const argType = typeof arg;\r\n\r\n        if (argType === 'string' || argType === 'number') {\r\n\r\n            classes.push(arg);\r\n\r\n        } else if (Array.isArray(arg)) {\r\n\r\n            if (arg.length) {\r\n\r\n                const inner = classNames.apply(null, arg);\r\n\r\n                if (inner) {\r\n                    classes.push(inner);\r\n                }\r\n            }\r\n\r\n        } else if (argType === 'object') {\r\n\r\n            if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {\r\n\r\n                classes.push(arg.toString());\r\n                continue;\r\n            }\r\n\r\n            for (var key in arg) {\r\n\r\n                if (hasOwn.call(arg, key) && arg[key]) {\r\n\r\n                    classes.push(key);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return classes.join(' ');\r\n}","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","import equal from 'fast-deep-equal';\r\nimport React, { memo } from 'react';\r\nimport { GridChildComponentProps as OriginalGridChildComponentProps } from 'react-window';\r\nimport { classNames } from './helpers';\r\nimport { ColumnType } from './table';\r\n\r\nexport const columnRowClassName = \"virtial-grid-item\";\r\n\r\nexport const defaultItemKey = <TData,>({ columnIndex, data, rowIndex }: { columnIndex: number, data: TData | undefined, rowIndex: number }) =>\r\n  `${rowIndex}:${columnIndex}`;\r\n\r\nexport interface GridChildComponentProps<RecordType extends Record<any, any> = any> extends OriginalGridChildComponentProps<readonly RecordType[]> {\r\n}\r\n\r\nexport interface VirtualTableCellProps<RecordType extends Record<any, any> = any> extends GridChildComponentProps<RecordType> {\r\n    originalColumnIndex: number,\r\n    column: ColumnType<RecordType>\r\n}\r\n\r\nexport function VirtualTableCell<RecordType extends Record<any, any> = any>(props: VirtualTableCellProps<RecordType>) {\r\n\r\n    const { style, column, data, originalColumnIndex, columnIndex, rowIndex, isScrolling } = props;\r\n\r\n    const row       = data && data[rowIndex];\r\n    const value     = column.dataIndex && row ? row[column.dataIndex as any] : undefined;\r\n    const cellProps = column.onCell && column.onCell(row, columnIndex, isScrolling);\r\n    const render    = column.render;\r\n    const content   = render ?\r\n                      render(value, row, columnIndex, isScrolling) :\r\n                      value as unknown as React.ReactNode;\r\n    \r\n    return (\r\n        <div\r\n            {...cellProps}\r\n            data-row-index={rowIndex}\r\n            data-column-index={columnIndex}\r\n            data-original-column-index={originalColumnIndex}\r\n            style={{\r\n                ...cellProps?.style,\r\n                ...style\r\n            }}\r\n            className={classNames(columnRowClassName, cellProps?.className)}\r\n        >\r\n            {content}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport const MemonableVirtualTableCell = memo(VirtualTableCell, (prevProps, nextProps) => {\r\n\r\n    // system index\r\n    if(prevProps.originalColumnIndex !== nextProps.originalColumnIndex\r\n    || prevProps.columnIndex         !== nextProps.columnIndex\r\n    || prevProps.rowIndex            !== nextProps.rowIndex) {\r\n        return false;\r\n    }\r\n\r\n    if (prevProps.style !== nextProps.style\r\n    && !equal(prevProps.style, nextProps.style)) {\r\n        return false;\r\n    }\r\n\r\n    // check handler\r\n    const shouldCellUpdate = nextProps.column.shouldCellUpdate;\r\n\r\n    if(shouldCellUpdate) {\r\n\r\n        const prevRecord  = prevProps.data;\r\n        const nextRecord  = nextProps.data;\r\n        const isScrolling = nextProps.isScrolling;\r\n\r\n        if(!shouldCellUpdate(nextRecord, prevRecord, isScrolling)) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    if(prevProps.data             === nextProps.data\r\n    && prevProps.column.dataIndex === nextProps.column.dataIndex\r\n    && prevProps.column.onCell    === nextProps.column.onCell\r\n    && prevProps.column.render    === nextProps.column.render) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n});","import { Align, VariableSizeGridProps } from \"react-window\";\r\nimport { columnGetter, Grid, InstanceProps, ItemMetadata, ItemMetadataMap, itemSizeGetter, ItemType } from \"./grid\";\r\n\r\nexport interface IGridProps<RecordType extends Record<any, any> = any> extends VariableSizeGridProps<readonly RecordType[]> {\r\n    rerenderFixedColumnOnHorizontalScroll?: boolean,\r\n    scrollbarSize?: number,\r\n    itemData: readonly RecordType[],\r\n    columnGetter: columnGetter<RecordType>,\r\n}\r\n\r\nexport const getItemMetadata = <TRecord extends Record<any, any> = any,>(\r\n    itemType: ItemType,\r\n    props: Grid<TRecord>['props'],\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n): ItemMetadata => {\r\n\r\n    let itemMetadataMap: ItemMetadataMap, itemSize: itemSizeGetter, lastMeasuredIndex: number;\r\n\r\n    if (itemType === 'column') {\r\n        itemMetadataMap = instanceProps.columnMetadataMap;\r\n        itemSize = props.columnWidth;\r\n        lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\r\n    } else {\r\n        itemMetadataMap = instanceProps.rowMetadataMap;\r\n        itemSize = props.rowHeight;\r\n        lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\r\n    }\r\n  \r\n    if (index > lastMeasuredIndex) {\r\n\r\n        let offset = 0;\r\n\r\n        if (lastMeasuredIndex >= 0) {\r\n            const itemMetadata = itemMetadataMap[lastMeasuredIndex];\r\n            offset = itemMetadata.offset + itemMetadata.size;\r\n        }\r\n  \r\n        for (let i = lastMeasuredIndex + 1; i <= index; i++) {\r\n\r\n            let size = itemSize(i);\r\n  \r\n            itemMetadataMap[i] = {\r\n                offset,\r\n                size,\r\n            };\r\n  \r\n            offset += size;\r\n        }\r\n  \r\n        if (itemType === 'column') {\r\n            instanceProps.lastMeasuredColumnIndex = index;\r\n        } else {\r\n            instanceProps.lastMeasuredRowIndex = index;\r\n        }\r\n    }\r\n\r\n    return itemMetadataMap[index];\r\n}\r\n\r\nexport const getEstimatedTotalHeight = <TRecord extends Record<any, any> = any,>(\r\n    { rowCount }: Grid<TRecord>['props'],\r\n    { rowMetadataMap, estimatedRowHeight, lastMeasuredRowIndex }: InstanceProps\r\n) => {\r\n    let totalSizeOfMeasuredRows = 0;\r\n  \r\n    // Edge case check for when the number of items decreases while a scroll is in progress.\r\n    // https://github.com/bvaughn/react-window/pull/138\r\n    if (lastMeasuredRowIndex >= rowCount) {\r\n        lastMeasuredRowIndex = rowCount - 1;\r\n    }\r\n  \r\n    if (lastMeasuredRowIndex >= 0) {\r\n        const itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\r\n        totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\r\n    }\r\n  \r\n    const numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\r\n    const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\r\n  \r\n    return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\r\n};\r\n\r\nexport const getEstimatedTotalWidth = <TRecord extends Record<any, any> = any,>(\r\n    { columnCount }: Grid<TRecord>['props'],\r\n    {\r\n        columnMetadataMap,\r\n        estimatedColumnWidth,\r\n        lastMeasuredColumnIndex,\r\n    }: InstanceProps\r\n) => {\r\n    let totalSizeOfMeasuredRows = 0;\r\n  \r\n    // Edge case check for when the number of items decreases while a scroll is in progress.\r\n    // https://github.com/bvaughn/react-window/pull/138\r\n    if (lastMeasuredColumnIndex >= columnCount) {\r\n        lastMeasuredColumnIndex = columnCount - 1;\r\n    }\r\n  \r\n    if (lastMeasuredColumnIndex >= 0) {\r\n        const itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\r\n        totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\r\n    }\r\n  \r\n    const numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\r\n    const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\r\n\r\n    return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\r\n};\r\n\r\nexport const getOffsetForIndexAndAlignment = <TRecord extends Record<any, any> = any,>(\r\n    itemType: ItemType,\r\n    props: Grid<TRecord>['props'],\r\n    index: number,\r\n    align: Align | undefined,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number,\r\n    sumOfLeftFixedColumnsWidth: number,\r\n    sumOfRightFixedColumnsWidth: number,\r\n  ): number => {\r\n\r\n    const leftOffset = itemType === 'column' ? sumOfLeftFixedColumnsWidth : 0;\r\n    const rightOffset = itemType === 'column' ? sumOfRightFixedColumnsWidth : 0;\r\n    const size = itemType === 'column' ? props.width : props.height;\r\n    const itemMetadata = getItemMetadata(itemType, props, index, instanceProps);\r\n\r\n    // Get estimated total size after ItemMetadata is computed,\r\n    // To ensure it reflects actual measurements instead of just estimates.\r\n    const estimatedTotalSize =\r\n        itemType === 'column'\r\n            ? getEstimatedTotalWidth(props, instanceProps)\r\n            : getEstimatedTotalHeight(props, instanceProps);\r\n\r\n    const maxOffset = Math.max(\r\n        0,\r\n        Math.min(estimatedTotalSize - size + leftOffset, itemMetadata.offset - leftOffset)\r\n    );\r\n\r\n    const minOffset = Math.max(\r\n        0,\r\n        itemMetadata.offset + itemMetadata.size - size + rightOffset + scrollbarSize\r\n    );\r\n\r\n    if (align === 'smart') {\r\n\r\n        if (\r\n            scrollOffset >= minOffset - size &&\r\n            scrollOffset <= maxOffset + size\r\n        ) {\r\n            align = 'auto';\r\n        } else {\r\n            align = 'center';\r\n        }\r\n    }\r\n\r\n    switch (align) {\r\n        case 'start':\r\n            return maxOffset;\r\n        case 'end':\r\n            return minOffset;\r\n        case 'center':\r\n            return Math.round(minOffset + (maxOffset - minOffset) / 2);\r\n        case 'auto':\r\n        default:\r\n            if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\r\n                return scrollOffset;\r\n            } else if (minOffset > maxOffset) {\r\n                // Because we only take into account the scrollbar size when calculating minOffset\r\n                // this value can be larger than maxOffset when at the end of the list\r\n                return minOffset;\r\n            } else if (scrollOffset < minOffset) {\r\n                return minOffset;\r\n            } else {\r\n                return maxOffset;\r\n            }\r\n    }\r\n}\r\n\r\nexport const getOffsetForColumnAndAlignment = <TRecord extends Record<any, any> = any,>(\r\n    props: Grid<TRecord>['props'],\r\n    index: number,\r\n    align: Align | undefined,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number,\r\n    sumOfLeftFixedColumnsWidth: number,\r\n    sumOfRightFixedColumnsWidth: number,\r\n): number =>\r\n    getOffsetForIndexAndAlignment(\r\n        'column',\r\n        props,\r\n        index,\r\n        align,\r\n        scrollOffset,\r\n        instanceProps,\r\n        scrollbarSize,\r\n        sumOfLeftFixedColumnsWidth,\r\n        sumOfRightFixedColumnsWidth\r\n    )\r\n\r\nexport const getOffsetForRowAndAlignment = <TRecord extends Record<any, any> = any,>(\r\n    props: Grid<TRecord>['props'],\r\n    index: number,\r\n    align: Align | undefined,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number,\r\n    sumOfLeftFixedColumnsWidth: number,\r\n    sumOfRightFixedColumnsWidth: number,\r\n): number =>\r\n    getOffsetForIndexAndAlignment(\r\n        'row',\r\n        props,\r\n        index,\r\n        align,\r\n        scrollOffset,\r\n        instanceProps,\r\n        scrollbarSize,\r\n        sumOfLeftFixedColumnsWidth,\r\n        sumOfRightFixedColumnsWidth\r\n    )\r\n\r\nexport const getRowOffset = <TRecord extends Record<any, any> = any,>(\r\n    props: Grid<TRecord>['props'],\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n): number => getItemMetadata('row', props, index, instanceProps).offset;\r\n\r\nexport const getRowHeightOrCalculate = <TRecord extends Record<any, any> = any,>(\r\n    props: Grid<TRecord>['props'],\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n): number => getItemMetadata('row', props, index, instanceProps).size;\r\n\r\nexport const getRowHeight = <TRecord extends Record<any, any> = any,>(\r\n    props: Grid<TRecord>['props'],\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n): number => instanceProps.rowMetadataMap[index].size;\r\n\r\nexport const getColumnWidth = <TRecord extends Record<any, any> = any,>(\r\n    props: Grid<TRecord>['props'],\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n): number => instanceProps.columnMetadataMap[index].size;\r\n\r\nexport const getColumnWidthOrCalculate = <TRecord extends Record<any, any> = any,>(\r\n    props: Grid<TRecord>['props'],\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n): number => getItemMetadata('column', props, index, instanceProps).size;","export default function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}","var safeIsNaN = Number.isNaN ||\n    function ponyfill(value) {\n        return typeof value === 'number' && value !== value;\n    };\nfunction isEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    if (safeIsNaN(first) && safeIsNaN(second)) {\n        return true;\n    }\n    return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (!isEqual(newInputs[i], lastInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\nexport default memoizeOne;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\nvar now = hasNativePerformanceNow ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nfunction cancelTimeout(timeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay) {\n  var start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  var timeoutID = {\n    id: requestAnimationFrame(tick)\n  };\n  return timeoutID;\n}\n\nvar size = -1; // This utility copied from \"dom-helpers\" package.\n\nfunction getScrollbarSize(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (size === -1 || recalculate) {\n    var div = document.createElement('div');\n    var style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n    document.body.appendChild(div);\n    size = div.offsetWidth - div.clientWidth;\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\nvar cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\n\nfunction getRTLOffsetType(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (cachedRTLResult === null || recalculate) {\n    var outerDiv = document.createElement('div');\n    var outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n    var innerDiv = document.createElement('div');\n    var innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nvar defaultItemKey = function defaultItemKey(_ref) {\n  var columnIndex = _ref.columnIndex,\n      data = _ref.data,\n      rowIndex = _ref.rowIndex;\n  return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsOverscanCount = null;\nvar devWarningsOverscanRowsColumnsCount = null;\nvar devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = /*#__PURE__*/new WeakSet();\n    devWarningsOverscanRowsColumnsCount = /*#__PURE__*/new WeakSet();\n    devWarningsTagName = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createGridComponent(_ref2) {\n  var _class;\n\n  var getColumnOffset = _ref2.getColumnOffset,\n      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,\n      getColumnWidth = _ref2.getColumnWidth,\n      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,\n      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,\n      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,\n      getRowHeight = _ref2.getRowHeight,\n      getRowOffset = _ref2.getRowOffset,\n      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,\n      initInstanceProps = _ref2.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref2.validateProps;\n  return _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(Grid, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function Grid(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._resetIsScrollingTimeoutId = null;\n      _this._outerRef = void 0;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        horizontalScrollDirection: 'forward',\n        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,\n        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,\n        scrollUpdateWasRequested: false,\n        verticalScrollDirection: 'forward'\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanColumnStartIndex: overscanColumnStartIndex,\n          overscanColumnStopIndex: overscanColumnStopIndex,\n          overscanRowStartIndex: overscanRowStartIndex,\n          overscanRowStopIndex: overscanRowStopIndex,\n          visibleColumnStartIndex: visibleColumnStartIndex,\n          visibleColumnStopIndex: visibleColumnStopIndex,\n          visibleRowStartIndex: visibleRowStartIndex,\n          visibleRowStopIndex: visibleRowStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          horizontalScrollDirection: horizontalScrollDirection,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          verticalScrollDirection: verticalScrollDirection,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (rowIndex, columnIndex) {\n        var _this$props = _this.props,\n            columnWidth = _this$props.columnWidth,\n            direction = _this$props.direction,\n            rowHeight = _this$props.rowHeight;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n\n        var key = rowIndex + \":\" + columnIndex;\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(key)) {\n          style = itemStyleCache[key];\n        } else {\n          var _offset = getColumnOffset(_this.props, columnIndex, _this._instanceProps);\n\n          var isRtl = direction === 'rtl';\n          itemStyleCache[key] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : _offset,\n            right: isRtl ? _offset : undefined,\n            top: getRowOffset(_this.props, rowIndex, _this._instanceProps),\n            height: getRowHeight(_this.props, rowIndex, _this._instanceProps),\n            width: getColumnWidth(_this.props, columnIndex, _this._instanceProps)\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScroll = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientHeight = _event$currentTarget.clientHeight,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollTop = _event$currentTarget.scrollTop,\n            scrollHeight = _event$currentTarget.scrollHeight,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n\n          var calculatedScrollLeft = scrollLeft;\n\n          if (direction === 'rtl') {\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                calculatedScrollLeft = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));\n          var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n            scrollLeft: calculatedScrollLeft,\n            scrollTop: calculatedScrollTop,\n            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1);\n        });\n      };\n\n      return _this;\n    }\n\n    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = Grid.prototype;\n\n    _proto.scrollTo = function scrollTo(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(function (prevState) {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(_ref4) {\n      var _ref4$align = _ref4.align,\n          align = _ref4$align === void 0 ? 'auto' : _ref4$align,\n          columnIndex = _ref4.columnIndex,\n          rowIndex = _ref4.rowIndex;\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          height = _this$props2.height,\n          rowCount = _this$props2.rowCount,\n          width = _this$props2.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n      var scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n\n      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n      this.scrollTo({\n        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n      });\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          initialScrollLeft = _this$props3.initialScrollLeft,\n          initialScrollTop = _this$props3.initialScrollTop;\n\n      if (this._outerRef != null) {\n        var outerRef = this._outerRef;\n\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var direction = this.props.direction;\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollTop = _this$state2.scrollTop,\n          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        var outerRef = this._outerRef;\n\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n\n            default:\n              var clientWidth = outerRef.clientWidth,\n                  scrollWidth = outerRef.scrollWidth;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          columnCount = _this$props4.columnCount,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          rowCount = _this$props4.rowCount,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),\n          columnStartIndex = _this$_getHorizontalR[0],\n          columnStopIndex = _this$_getHorizontalR[1];\n\n      var _this$_getVerticalRan = this._getVerticalRangeToRender(),\n          rowStartIndex = _this$_getVerticalRan[0],\n          rowStopIndex = _this$_getVerticalRan[1];\n\n      var items = [];\n\n      if (columnCount > 0 && rowCount) {\n        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {\n          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {\n            items.push(createElement(children, {\n              columnIndex: _columnIndex,\n              data: itemData,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              key: itemKey({\n                columnIndex: _columnIndex,\n                data: itemData,\n                rowIndex: _rowIndex\n              }),\n              rowIndex: _rowIndex,\n              style: this._getItemStyle(_rowIndex, _columnIndex)\n            }));\n          }\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: this._onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalHeight,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: estimatedTotalWidth\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      var _this$props5 = this.props,\n          columnCount = _this$props5.columnCount,\n          onItemsRendered = _this$props5.onItemsRendered,\n          onScroll = _this$props5.onScroll,\n          rowCount = _this$props5.rowCount;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),\n              _overscanColumnStartIndex = _this$_getHorizontalR2[0],\n              _overscanColumnStopIndex = _this$_getHorizontalR2[1],\n              _visibleColumnStartIndex = _this$_getHorizontalR2[2],\n              _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n\n          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),\n              _overscanRowStartIndex = _this$_getVerticalRan2[0],\n              _overscanRowStopIndex = _this$_getVerticalRan2[1],\n              _visibleRowStartIndex = _this$_getVerticalRan2[2],\n              _visibleRowStopIndex = _this$_getVerticalRan2[3];\n\n          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        var _this$state3 = this.state,\n            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,\n            _scrollLeft = _this$state3.scrollLeft,\n            _scrollTop = _this$state3.scrollTop,\n            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,\n            _verticalScrollDirection = _this$state3.verticalScrollDirection;\n\n        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n      var _this$props6 = this.props,\n          columnCount = _this$props6.columnCount,\n          overscanColumnCount = _this$props6.overscanColumnCount,\n          overscanColumnsCount = _this$props6.overscanColumnsCount,\n          overscanCount = _this$props6.overscanCount,\n          rowCount = _this$props6.rowCount;\n      var _this$state4 = this.state,\n          horizontalScrollDirection = _this$state4.horizontalScrollDirection,\n          isScrolling = _this$state4.isScrolling,\n          scrollLeft = _this$state4.scrollLeft;\n      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n      var _this$props7 = this.props,\n          columnCount = _this$props7.columnCount,\n          overscanCount = _this$props7.overscanCount,\n          overscanRowCount = _this$props7.overscanRowCount,\n          overscanRowsCount = _this$props7.overscanRowsCount,\n          rowCount = _this$props7.rowCount;\n      var _this$state5 = this.state,\n          isScrolling = _this$state5.isScrolling,\n          verticalScrollDirection = _this$state5.verticalScrollDirection,\n          scrollTop = _this$state5.scrollTop;\n      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return Grid;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    useIsScrolling: false\n  }, _class;\n}\n\nvar validateSharedProps = function validateSharedProps(_ref5, _ref6) {\n  var children = _ref5.children,\n      direction = _ref5.direction,\n      height = _ref5.height,\n      innerTagName = _ref5.innerTagName,\n      outerTagName = _ref5.outerTagName,\n      overscanColumnsCount = _ref5.overscanColumnsCount,\n      overscanCount = _ref5.overscanCount,\n      overscanRowsCount = _ref5.overscanRowsCount,\n      width = _ref5.width;\n  var instance = _ref6.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn('The overscanCount prop has been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (typeof overscanColumnsCount === 'number' || typeof overscanRowsCount === 'number') {\n      if (devWarningsOverscanRowsColumnsCount && !devWarningsOverscanRowsColumnsCount.has(instance)) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn('The overscanColumnsCount and overscanRowsCount props have been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    if (typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Grids must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    }\n\n    if (typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Grids must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n  var rowCount = _ref.rowCount;\n  var rowMetadataMap = _ref2.rowMetadataMap,\n      estimatedRowHeight = _ref2.estimatedRowHeight,\n      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n  var columnCount = _ref3.columnCount;\n  var columnMetadataMap = _ref4.columnMetadataMap,\n      estimatedColumnWidth = _ref4.estimatedColumnWidth,\n      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {\n  var itemMetadataMap, itemSize, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = props.columnWidth;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = props.rowHeight;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n  var itemMetadataMap, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n  var size = itemType === 'column' ? props.width : props.height;\n  var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n\n  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n\n    case 'end':\n      return minOffset;\n\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n\n  }\n};\n\nvar VariableSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n    return getItemMetadata('column', props, index, instanceProps).offset;\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n    return findNearestItem('column', props, instanceProps, scrollLeft);\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n    var columnCount = props.columnCount,\n        width = props.width;\n    var itemMetadata = getItemMetadata('column', props, startIndex, instanceProps);\n    var maxOffset = scrollLeft + width;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n    return instanceProps.columnMetadataMap[index].size;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getRowOffset: function getRowOffset(props, index, instanceProps) {\n    return getItemMetadata('row', props, index, instanceProps).offset;\n  },\n  getRowHeight: function getRowHeight(props, index, instanceProps) {\n    return instanceProps.rowMetadataMap[index].size;\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n    return findNearestItem('row', props, instanceProps, scrollTop);\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n    var rowCount = props.rowCount,\n        height = props.height;\n    var itemMetadata = getItemMetadata('row', props, startIndex, instanceProps);\n    var maxOffset = scrollTop + height;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref5 = props,\n        estimatedColumnWidth = _ref5.estimatedColumnWidth,\n        estimatedRowHeight = _ref5.estimatedRowHeight;\n    var instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {}\n    };\n\n    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        columnIndex: columnIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        rowIndex: rowIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterIndices = function (_ref6) {\n      var columnIndex = _ref6.columnIndex,\n          rowIndex = _ref6.rowIndex,\n          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,\n          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n      }\n\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n      } // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref7) {\n    var columnWidth = _ref7.columnWidth,\n        rowHeight = _ref7.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      } else if (typeof rowHeight !== 'function') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\n\nvar defaultItemKey$1 = function defaultItemKey(index, data) {\n  return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsDirection = null;\nvar devWarningsTagName$1 = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = /*#__PURE__*/new WeakSet();\n    devWarningsTagName$1 = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createListComponent(_ref) {\n  var _class;\n\n  var getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getItemSize = _ref.getItemSize,\n      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initInstanceProps = _ref.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref.validateProps;\n  return _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(List, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function List(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._outerRef = void 0;\n      _this._resetIsScrollingTimeoutId = null;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,\n        scrollUpdateWasRequested: false\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanStartIndex: overscanStartIndex,\n          overscanStopIndex: overscanStopIndex,\n          visibleStartIndex: visibleStartIndex,\n          visibleStopIndex: visibleStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          scrollDirection: scrollDirection,\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (index) {\n        var _this$props = _this.props,\n            direction = _this$props.direction,\n            itemSize = _this$props.itemSize,\n            layout = _this$props.layout;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n\n          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n\n          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n          var isRtl = direction === 'rtl';\n          var offsetHorizontal = isHorizontal ? _offset : 0;\n          itemStyleCache[index] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : offsetHorizontal,\n            right: isRtl ? offsetHorizontal : undefined,\n            top: !isHorizontal ? _offset : 0,\n            height: !isHorizontal ? size : '100%',\n            width: isHorizontal ? size : '100%'\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScrollHorizontal = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollLeft) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction;\n          var scrollOffset = scrollLeft;\n\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n            // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                scrollOffset = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._onScrollVertical = function (event) {\n        var _event$currentTarget2 = event.currentTarget,\n            clientHeight = _event$currentTarget2.clientHeight,\n            scrollHeight = _event$currentTarget2.scrollHeight,\n            scrollTop = _event$currentTarget2.scrollTop;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1, null);\n        });\n      };\n\n      return _this;\n    }\n\n    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps$1(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = List.prototype;\n\n    _proto.scrollTo = function scrollTo(scrollOffset) {\n      scrollOffset = Math.max(0, scrollOffset);\n      this.setState(function (prevState) {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(index, align) {\n      if (align === void 0) {\n        align = 'auto';\n      }\n\n      var _this$props2 = this.props,\n          itemCount = _this$props2.itemCount,\n          layout = _this$props2.layout;\n      var scrollOffset = this.state.scrollOffset;\n      index = Math.max(0, Math.min(index, itemCount - 1)); // The scrollbar size should be considered when scrolling an item into view, to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n      // This is an edge case for lists; normally they only scroll in the dominant direction.\n\n      var scrollbarSize = 0;\n\n      if (this._outerRef) {\n        var outerRef = this._outerRef;\n\n        if (layout === 'vertical') {\n          scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;\n        } else {\n          scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;\n        }\n      }\n\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps, scrollbarSize));\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          direction = _this$props3.direction,\n          initialScrollOffset = _this$props3.initialScrollOffset,\n          layout = _this$props3.layout;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$props4 = this.props,\n          direction = _this$props4.direction,\n          layout = _this$props4.layout;\n      var _this$state = this.state,\n          scrollOffset = _this$state.scrollOffset,\n          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n\n              default:\n                var clientWidth = outerRef.clientWidth,\n                    scrollWidth = outerRef.scrollWidth;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props5 = this.props,\n          children = _this$props5.children,\n          className = _this$props5.className,\n          direction = _this$props5.direction,\n          height = _this$props5.height,\n          innerRef = _this$props5.innerRef,\n          innerElementType = _this$props5.innerElementType,\n          innerTagName = _this$props5.innerTagName,\n          itemCount = _this$props5.itemCount,\n          itemData = _this$props5.itemData,\n          _this$props5$itemKey = _this$props5.itemKey,\n          itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey,\n          layout = _this$props5.layout,\n          outerElementType = _this$props5.outerElementType,\n          outerTagName = _this$props5.outerTagName,\n          style = _this$props5.style,\n          useIsScrolling = _this$props5.useIsScrolling,\n          width = _this$props5.width;\n      var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n\n      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n\n      var _this$_getRangeToRend = this._getRangeToRender(),\n          startIndex = _this$_getRangeToRend[0],\n          stopIndex = _this$_getRangeToRend[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(_index, itemData),\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(_index)\n          }));\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: isHorizontal ? '100%' : estimatedTotalSize,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: isHorizontal ? estimatedTotalSize : '100%'\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        var itemCount = this.props.itemCount;\n\n        if (itemCount > 0) {\n          var _this$_getRangeToRend2 = this._getRangeToRender(),\n              _overscanStartIndex = _this$_getRangeToRend2[0],\n              _overscanStopIndex = _this$_getRangeToRend2[1],\n              _visibleStartIndex = _this$_getRangeToRend2[2],\n              _visibleStopIndex = _this$_getRangeToRend2[3];\n\n          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        var _this$state2 = this.state,\n            _scrollDirection = _this$state2.scrollDirection,\n            _scrollOffset = _this$state2.scrollOffset,\n            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getRangeToRender = function _getRangeToRender() {\n      var _this$props6 = this.props,\n          itemCount = _this$props6.itemCount,\n          overscanCount = _this$props6.overscanCount;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollDirection = _this$state3.scrollDirection,\n          scrollOffset = _this$state3.scrollOffset;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return List;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _class;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nvar validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {\n  var children = _ref2.children,\n      direction = _ref2.direction,\n      height = _ref2.height,\n      layout = _ref2.layout,\n      innerTagName = _ref2.innerTagName,\n      outerTagName = _ref2.outerTagName,\n      width = _ref2.width;\n  var instance = _ref3.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n        devWarningsTagName$1.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    } // TODO Deprecate direction \"horizontal\"\n\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n        }\n\n        break;\n\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + (\"\\\"\" + layout + \"\\\" was specified.\"));\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\n\nvar getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {\n  var _ref = props,\n      itemSize = _ref.itemSize;\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n  var itemCount = props.itemCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {\n  var itemCount = _ref2.itemCount;\n  var itemMetadataMap = _ref3.itemMetadataMap,\n      estimatedItemSize = _ref3.estimatedItemSize,\n      lastMeasuredIndex = _ref3.lastMeasuredIndex;\n  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar VariableSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata$1(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    return instanceProps.itemMetadataMap[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    var direction = props.direction,\n        height = props.height,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size + scrollbarSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    return findNearestItem$1(props, instanceProps, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        itemCount = props.itemCount,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref4 = props,\n        estimatedItemSize = _ref4.estimatedItemSize;\n    var instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return index * columnWidth;\n  },\n  getColumnWidth: function getColumnWidth(_ref2, index) {\n    var columnWidth = _ref2.columnWidth;\n    return columnWidth;\n  },\n  getRowOffset: function getRowOffset(_ref3, index) {\n    var rowHeight = _ref3.rowHeight;\n    return index * rowHeight;\n  },\n  getRowHeight: function getRowHeight(_ref4, index) {\n    var rowHeight = _ref4.rowHeight;\n    return rowHeight;\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n    var rowCount = _ref5.rowCount,\n        rowHeight = _ref5.rowHeight;\n    return rowHeight * rowCount;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n    var columnCount = _ref6.columnCount,\n        columnWidth = _ref6.columnWidth;\n    return columnWidth * columnCount;\n  },\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n    var columnCount = _ref7.columnCount,\n        columnWidth = _ref7.columnWidth,\n        width = _ref7.width;\n    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);\n    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n    var rowHeight = _ref8.rowHeight,\n        height = _ref8.height,\n        rowCount = _ref8.rowCount;\n    var lastRowOffset = Math.max(0, rowCount * rowHeight - height);\n    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n    var columnWidth = _ref9.columnWidth,\n        columnCount = _ref9.columnCount;\n    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n    var columnWidth = _ref10.columnWidth,\n        columnCount = _ref10.columnCount,\n        width = _ref10.width;\n    var left = startIndex * columnWidth;\n    var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n    var rowHeight = _ref11.rowHeight,\n        rowCount = _ref11.rowCount;\n    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n    var rowHeight = _ref12.rowHeight,\n        rowCount = _ref12.rowCount,\n        height = _ref12.height;\n    var top = startIndex * rowHeight;\n    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref13) {\n    var columnWidth = _ref13.columnWidth,\n        rowHeight = _ref13.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2, index) {\n    var itemSize = _ref2.itemSize;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var itemCount = _ref3.itemCount,\n        itemSize = _ref3.itemSize;\n    return itemSize * itemCount;\n  },\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    var direction = _ref4.direction,\n        height = _ref4.height,\n        itemCount = _ref4.itemCount,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var lastItemOffset = Math.max(0, itemCount * itemSize - size);\n    var maxOffset = Math.min(lastItemOffset, index * itemSize);\n    var minOffset = Math.max(0, index * itemSize - size + itemSize + scrollbarSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        {\n          // \"Centered\" offset is usually the average of the min and max.\n          // But near the edges of the list, this doesn't hold true.\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0; // near the beginning\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset; // near the end\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var itemCount = _ref5.itemCount,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var direction = _ref6.direction,\n        height = _ref6.height,\n        itemCount = _ref6.itemCount,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var offset = startIndex * itemSize;\n    var size = isHorizontal ? width : height;\n    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref7) {\n    var itemSize = _ref7.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar _excluded = [\"style\"],\n    _excluded2 = [\"style\"];\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\n\nfunction areEqual(prevProps, nextProps) {\n  var prevStyle = prevProps.style,\n      prevRest = _objectWithoutPropertiesLoose(prevProps, _excluded);\n\n  var nextStyle = nextProps.style,\n      nextRest = _objectWithoutPropertiesLoose(nextProps, _excluded2);\n\n  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n\nexport { FixedSizeGrid, FixedSizeList, VariableSizeGrid, VariableSizeList, areEqual, shouldComponentUpdate };\n//# sourceMappingURL=index.esm.js.map\n","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}","import React, { createElement } from \"react\";\r\nimport { Align, VariableSizeGridProps, GridOnScrollProps } from \"react-window\";\r\nimport { getScrollbarSize } from \"./dom-helpers\";\r\nimport { classNames, isFunction } from \"./helpers\";\r\nimport { defaultItemKey } from \"./cell\";\r\nimport { ColumnType } from \"./table\";\r\nimport { getEstimatedTotalHeight, getEstimatedTotalWidth, getOffsetForColumnAndAlignment, getOffsetForRowAndAlignment } from './grid-helpers';\r\n\r\nexport type columnGetter<TRecord extends Record<any, any> = any> = (index: number) => ColumnType<TRecord>;\r\nexport type itemSizeGetter = (index: number) => number;\r\nexport type ItemType = 'column' | 'row';\r\n\r\nexport type ScrollEvent = React.SyntheticEvent<ScrollEvent>;\r\n\r\nexport type ItemMetadata = {\r\n    offset: number,\r\n    size: number,\r\n}\r\n\r\nexport type ItemMetadataMap = { [index: number]: ItemMetadata }\r\n\r\nexport type InstanceProps = {\r\n    columnMetadataMap: ItemMetadataMap,\r\n    estimatedColumnWidth: number,\r\n    estimatedRowHeight: number,\r\n    lastMeasuredColumnIndex: number,\r\n    lastMeasuredRowIndex: number,\r\n    rowMetadataMap: ItemMetadataMap,\r\n}\r\n\r\nexport interface IItemStyle extends React.CSSProperties {\r\n    position: React.CSSProperties['position'],\r\n    left: number,\r\n    right: number,\r\n    top: number,\r\n    height: number,\r\n    width: number,\r\n}\r\n\r\nconst defaultRowClassName = \"virtial-grid-row\";\r\nconst defaultFixedRowClassName = \"fixed-virtial-grid-row-columns\";\r\nconst defaultFixedRowLeftColumnsClassName = \"fixed-virtial-grid-row-left-columns\";\r\nconst defaultFixedRowRightColumnsClassName = \"fixed-virtial-grid-row-right-columns\";\r\nconst defaultHasFixedLeftColumnClassName = \"has-fixed-left-column\";\r\nconst defaultHasFixedRightColumnClassName = \"has-fixed-right-column\";\r\n\r\nexport type OnScrollProps = GridOnScrollProps;\r\nexport type OnScrollCallback = (props: OnScrollProps) => void;\r\n\r\nexport interface IGrid<RecordType extends Record<any, any> = any> extends Omit<VariableSizeGrid<readonly RecordType[]>, 'props' | 'state'> {\r\n    props: IGridProps<RecordType>;\r\n    state: Readonly<IGridState>;\r\n}\r\n\r\nexport interface IScrollToParams {\r\n    scrollLeft?: number | undefined;\r\n    scrollTop?: number | undefined;\r\n}\r\n\r\nexport interface IScrollToItemParams {\r\n    align?: Align | undefined;\r\n    columnIndex?: number | undefined;\r\n    rowIndex?: number | undefined;\r\n}\r\n\r\nexport interface IResetAfterIndicesParams {\r\n    columnIndex: number;\r\n    rowIndex: number;\r\n    shouldForceUpdate?: boolean | undefined;\r\n}\r\n\r\nexport interface IGridState {\r\n    isScrolling: boolean,\r\n    scrollTop: number,\r\n    scrollLeft: number,\r\n}\r\n\r\nexport interface IGridProps<RecordType extends Record<any, any> = any> extends VariableSizeGridProps<readonly RecordType[]> {\r\n    rerenderFixedColumnOnHorizontalScroll?: boolean,\r\n    rowClassName?: (record: RecordType, index: number) => string,\r\n    onRow?: (record: RecordType, index: number) => React.HTMLAttributes<HTMLDivElement>;\r\n    rowKey?: string | ((record: RecordType) => string), \r\n    scrollbarSize?: number,\r\n    itemData: readonly RecordType[],\r\n    columnGetter: columnGetter<RecordType>,\r\n}\r\n\r\n/*#if _BUILDLIB*/\r\n//import { VariableSizeGrid } from './react-window-grid-d';\r\n//#else*/\r\nimport { VariableSizeGrid } from './react-window-grid.js';\r\n//#endif\r\n\r\nexport class Grid<RecordType extends Record<any, any> = any> extends VariableSizeGrid<RecordType> {\r\n\r\n    private _leftFixedColumnsWidth = 0;\r\n    private _rightFixedColumnsWidth = 0;\r\n\r\n    private _firstUnFixedColumn = 0;\r\n\r\n    /** может быть равен <b>props.columnCount</b>, когда нет фиксированных колонок справо */\r\n    private _firstRightFixedColumn = 0;\r\n\r\n    private _lastFixedRenderedContent: Record<number | string, [React.ReactElement[], React.ReactElement[]]> | undefined;\r\n    private _lastFixedRenderedRowStartIndex: number | undefined;\r\n    private _lastFixedRenderedRowStopIndex: number | undefined\r\n\r\n    constructor(props: IGridProps<RecordType>) {\r\n        super(props);\r\n        this._updateFixedColumnsVars();\r\n    }\r\n\r\n    private _updateFixedColumnsVars() {\r\n\r\n        const { columnCount, columnGetter, columnWidth } = this.props;\r\n\r\n        this._firstUnFixedColumn = 0;\r\n        this._firstRightFixedColumn = columnCount;\r\n        this._leftFixedColumnsWidth = 0;\r\n        this._rightFixedColumnsWidth = 0;\r\n\r\n        this._lastFixedRenderedContent = undefined;\r\n        this._lastFixedRenderedRowStartIndex = undefined;\r\n        this._lastFixedRenderedRowStopIndex = undefined;\r\n\r\n        for (let columnIndex = 0; columnIndex < columnCount; columnIndex++) {\r\n\r\n            let column = columnGetter(columnIndex);\r\n\r\n            if (column.fixed === 'left' || column.fixed === true) {\r\n                this._firstUnFixedColumn++;\r\n                this._leftFixedColumnsWidth += columnWidth(columnIndex);\r\n                continue;\r\n            }\r\n\r\n            break;\r\n        }\r\n\r\n        for (let columnIndex = columnCount - 1; columnIndex > -1; columnIndex--) {\r\n\r\n            let column = columnGetter(columnIndex);\r\n\r\n            if (column.fixed === 'right') {\r\n                this._firstRightFixedColumn--;\r\n                this._rightFixedColumnsWidth += columnWidth(columnIndex);\r\n                continue;\r\n            }\r\n\r\n            break;\r\n        }\r\n    }\r\n\r\n    _renderFixedColumns(rowStartIndex: number, rowStopIndex: number, update: boolean = false) {\r\n\r\n        const { rerenderFixedColumnOnHorizontalScroll, columnWidth, rowHeight } = this.props;\r\n\r\n        if(rerenderFixedColumnOnHorizontalScroll === false\r\n        && update === false\r\n        && this._lastFixedRenderedRowStartIndex === rowStartIndex\r\n        && this._lastFixedRenderedRowStopIndex === rowStopIndex\r\n        && this._lastFixedRenderedContent) {\r\n            return this._lastFixedRenderedContent;\r\n        }\r\n        \r\n        const { children, itemData, columnCount, useIsScrolling, itemKey = defaultItemKey } = this.props;\r\n        const { isScrolling } = this.state;\r\n\r\n        const rows: typeof this._lastFixedRenderedContent = {};\r\n        const shownRowsCount = rowStopIndex - rowStartIndex + 1;\r\n    \r\n        // нет смысла рендерить скрытые колонки\r\n        if(this._leftFixedColumnsWidth > 0\r\n        || this._rightFixedColumnsWidth > 0) {\r\n    \r\n            for (\r\n                let visibleRowIndex = 0;\r\n                visibleRowIndex < shownRowsCount;\r\n                visibleRowIndex++\r\n            ) {\r\n                const rowLeftColumns: React.ReactElement[] = [];\r\n                const rowRightColumns: React.ReactElement[] = [];\r\n                const rowIndex = rowStartIndex + visibleRowIndex;\r\n                const height = rowHeight(rowIndex);\r\n\r\n                const renderFixedColumn = (columnIndex: number) => {\r\n\r\n                    const width = columnWidth(columnIndex);\r\n                    return createElement(children, {\r\n                        key: itemKey({ columnIndex, data: itemData, rowIndex }),\r\n                        rowIndex,\r\n                        columnIndex,\r\n                        data: itemData,\r\n                        isScrolling: useIsScrolling ? isScrolling : undefined,\r\n                        style: {\r\n                            width: width,\r\n                            height: height,\r\n                        }\r\n                    });\r\n                }\r\n\r\n                for (\r\n                    let columnIndex = 0;\r\n                    columnIndex < this._firstUnFixedColumn;\r\n                    columnIndex++\r\n                ) {\r\n                    const item = renderFixedColumn(columnIndex);\r\n                    rowLeftColumns.push(item);\r\n                }\r\n\r\n                for (\r\n                    let columnIndex = this._firstRightFixedColumn;\r\n                    columnIndex < columnCount;\r\n                    columnIndex++\r\n                ) {\r\n                    const item = renderFixedColumn(columnIndex);\r\n                    rowRightColumns.push(item);\r\n                }\r\n    \r\n                if (rowLeftColumns.length > 0 || rowRightColumns.length > 0) {\r\n                    rows[rowIndex] = [rowLeftColumns, rowRightColumns];\r\n                }\r\n            }\r\n        }\r\n    \r\n        this._lastFixedRenderedRowStartIndex = rowStartIndex;\r\n        this._lastFixedRenderedRowStopIndex = rowStopIndex;\r\n        this._lastFixedRenderedContent = rows;\r\n\r\n        return rows;\r\n    }\r\n\r\n    scrollToItem({ align, rowIndex, columnIndex }: IScrollToItemParams) {\r\n\r\n        const { columnCount, height, rowCount, width } = this.props;\r\n        const { scrollLeft, scrollTop } = this.state;\r\n        const { scrollbarSize = getScrollbarSize() } = this.props;\r\n    \r\n        if (columnIndex !== undefined) {\r\n            columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\r\n        }\r\n    \r\n        if (rowIndex !== undefined) {\r\n            rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\r\n        }\r\n    \r\n        const estimatedTotalHeight = getEstimatedTotalHeight(\r\n            this.props,\r\n            this._instanceProps\r\n        );\r\n    \r\n        const estimatedTotalWidth = getEstimatedTotalWidth(\r\n            this.props,\r\n            this._instanceProps\r\n        );\r\n    \r\n        // The scrollbar size should be considered when scrolling an item into view,\r\n        // to ensure it's fully visible.\r\n        // But we only need to account for its size when it's actually visible.\r\n        const horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\r\n        const verticalScrollbarSize   = estimatedTotalHeight > height ? scrollbarSize : 0;\r\n    \r\n        this.scrollTo({\r\n            scrollLeft:\r\n                columnIndex !== undefined\r\n                    ? getOffsetForColumnAndAlignment(\r\n                        this.props,\r\n                        columnIndex,\r\n                        align,\r\n                        scrollLeft,\r\n                        this._instanceProps,\r\n                        verticalScrollbarSize,\r\n                        this._leftFixedColumnsWidth,\r\n                        this._rightFixedColumnsWidth,\r\n                    )\r\n                    : scrollLeft,\r\n                scrollTop:\r\n                    rowIndex !== undefined\r\n                        ? getOffsetForRowAndAlignment(\r\n                            this.props,\r\n                            rowIndex,\r\n                            align,\r\n                            scrollTop,\r\n                            this._instanceProps,\r\n                            horizontalScrollbarSize,\r\n                            this._leftFixedColumnsWidth,\r\n                            this._rightFixedColumnsWidth,\r\n                        )\r\n                        : scrollTop,\r\n        });\r\n    }\r\n\r\n    render() {\r\n\r\n        const {\r\n            className,\r\n            columnCount,\r\n            height,\r\n            innerRef,\r\n            innerElementType,\r\n            innerTagName,\r\n            outerElementType,\r\n            outerTagName,\r\n            rowCount,\r\n            direction,\r\n            style,\r\n            width,\r\n\r\n            useIsScrolling,\r\n            itemData,\r\n            rowClassName,\r\n            onRow,\r\n            children,\r\n            rowKey,\r\n            itemKey = defaultItemKey,\r\n\r\n        } = this.props;\r\n\r\n        const { isScrolling } = this.state;\r\n    \r\n        const rowsColumns: Record<number | string, Record<number | string, React.ReactElement>> = {};\r\n        const rowsElementProps: Record<number | string, React.HTMLAttributes<HTMLDivElement> & { key: string }> = {};\r\n\r\n        let rowsFixedColumns: typeof this._lastFixedRenderedContent;\r\n\r\n        if(columnCount > 0\r\n        && rowCount > 0) {\r\n\r\n            const [columnStartIndex, columnStopIndex, ] = this._getHorizontalRangeToRender();\r\n            const [rowStartIndex, rowStopIndex] = this._getVerticalRangeToRender();\r\n\r\n            rowsFixedColumns = this._renderFixedColumns(rowStartIndex, rowStopIndex);\r\n\r\n            for (\r\n                let rowIndex = rowStartIndex;\r\n                rowIndex <= rowStopIndex;\r\n                rowIndex++\r\n            ) {\r\n                const record = itemData[rowIndex];\r\n                const className = rowClassName\r\n                                ? rowClassName(record, rowIndex)\r\n                                : undefined;\r\n                \r\n                const divProps = onRow\r\n                               ? onRow(record, rowIndex)\r\n                               : undefined;\r\n            \r\n                const key = isFunction(rowKey)\r\n                          ? rowKey(record)\r\n                          : rowKey ?? `${rowIndex}`;\r\n                \r\n                const firstItemStyle = this._getItemStyle(rowIndex, this._firstUnFixedColumn);\r\n                const firstUnFixedColumn = this._firstUnFixedColumn;\r\n                const firstRightFixedColumn = this._firstRightFixedColumn;\r\n                const rowColumns: Record<number, React.ReactElement> = [];\r\n\r\n                for (\r\n                    let columnIndex = columnStartIndex;\r\n                    columnIndex <= columnStopIndex;\r\n                    columnIndex++\r\n                ) {\r\n                    \r\n                    if(columnIndex < firstUnFixedColumn\r\n                    || columnIndex > firstRightFixedColumn - 1) {\r\n                        continue;\r\n                    }\r\n            \r\n                    const key = itemKey({ columnIndex, data: itemData, rowIndex });\r\n                    const style = this._getItemStyle(rowIndex, columnIndex);\r\n\r\n                    rowColumns[columnIndex] = createElement(children, {\r\n                        columnIndex,\r\n                        data: itemData,\r\n                        isScrolling: useIsScrolling ? isScrolling : undefined,\r\n                        key: key,\r\n                        rowIndex,\r\n                        style: style,\r\n                    });\r\n                }\r\n                \r\n                rowsColumns[rowIndex] = rowColumns;\r\n                rowsElementProps[rowIndex] = {\r\n                    ...divProps,\r\n                    key: key,\r\n                    style: {\r\n                        ...divProps?.style,\r\n                        top: firstItemStyle.top\r\n                    },\r\n                    className: classNames(\r\n                        defaultRowClassName,\r\n                        className,\r\n                        divProps?.className\r\n                    )\r\n                }\r\n            }\r\n        }\r\n    \r\n        // Read this value AFTER items have been created,\r\n        // So their actual sizes (if variable) are taken into consideration.\r\n        const estimatedTotalHeight = getEstimatedTotalHeight(\r\n            this.props,\r\n            this._instanceProps\r\n        );\r\n        const estimatedTotalWidth = getEstimatedTotalWidth(\r\n            this.props,\r\n            this._instanceProps\r\n        );\r\n\r\n        const rows = Object.entries(rowsElementProps).map(([rowIndex, props]) => {\r\n            \r\n            const { top, left } = props.style || {};\r\n            const rowFixedColumns = rowsFixedColumns ? rowsFixedColumns[rowIndex] : [];\r\n            const fixedLeftColumns = rowFixedColumns[0];\r\n            const fixedRightColumns = rowFixedColumns[1];\r\n            const columns = Object.values(rowsColumns[rowIndex]);\r\n\r\n            return (\r\n                <div\r\n                    {...props}\r\n                >\r\n                    {columns}\r\n                    <div\r\n                        className={defaultFixedRowClassName}\r\n                        style={{\r\n                            top: top,\r\n                            left: left,\r\n                            width: estimatedTotalWidth\r\n                        }}\r\n                    >\r\n                        {fixedLeftColumns && fixedLeftColumns.length > 0 &&\r\n                        <div className={defaultFixedRowLeftColumnsClassName}>\r\n                            {fixedLeftColumns}\r\n                        </div>}\r\n                        {fixedRightColumns && fixedRightColumns.length > 0 &&\r\n                        <div className={defaultFixedRowRightColumnsClassName}>\r\n                            {fixedRightColumns}\r\n                        </div>}\r\n                    </div>\r\n                </div>\r\n            );\r\n        });\r\n\r\n        const hasFixedLeftColumn  = this._leftFixedColumnsWidth > 0;\r\n        const hasFixedRightColumn = this._rightFixedColumnsWidth > 0;\r\n\r\n        return createElement(\r\n            outerElementType || outerTagName || 'div',\r\n            {\r\n                className: classNames(className, {\r\n                    [defaultHasFixedLeftColumnClassName]: hasFixedLeftColumn,\r\n                    [defaultHasFixedRightColumnClassName]: hasFixedRightColumn\r\n                }),\r\n                onScroll: this._onScroll,\r\n                ref: this._outerRefSetter,\r\n                style: {\r\n                    position: 'relative',\r\n                    height,\r\n                    width,\r\n                    overflow: 'auto',\r\n                    WebkitOverflowScrolling: 'touch',\r\n                    willChange: 'transform',\r\n                    direction,\r\n                    ...style,\r\n                },\r\n            },\r\n            createElement(innerElementType || innerTagName || 'div', {\r\n                children: rows,\r\n                ref: innerRef,\r\n                style: {\r\n                    height: estimatedTotalHeight,\r\n                    pointerEvents: isScrolling ? 'none' : undefined,\r\n                    width: estimatedTotalWidth,\r\n                },\r\n            })\r\n        );\r\n    }\r\n\r\n    componentDidUpdate(prevProps: IGridProps<RecordType>, prevState: IGridState, snapshot: any): void {\r\n\r\n        if(prevProps.columnGetter !== this.props.columnGetter\r\n        || prevProps.columnCount !== this.props.columnCount\r\n        || prevProps.columnWidth !== this.props.columnWidth) {\r\n            this._updateFixedColumnsVars();\r\n        }\r\n\r\n        // @ts-ignore\r\n        super.componentDidUpdate(prevProps, prevState, snapshot);\r\n    }\r\n}","import React, { Ref, useEffect } from 'react';\r\nimport { ConfigProvider, Empty, Table, TableProps, TableColumnType as AntdTableColumnType } from 'antd';\r\nimport { useCallback, useMemo, useRef, useState } from 'react';\r\nimport { Grid, OnScrollCallback, OnScrollProps } from './grid';\r\nimport { assignRef, classNames, isFunction, refSetter, sumColumnWidths, sumRowsHeights } from './helpers';\r\nimport { GridChildComponentProps, MemonableVirtualTableCell } from './cell';\r\nimport { TableComponents } from 'rc-table/lib/interface';\r\n\r\nimport './style.css';\r\nimport { flushSync } from 'react-dom';\r\n\r\nexport interface InfoRef {\r\n    scrollLeft: number;\r\n}\r\n\r\nexport interface Info {\r\n    scrollbarSize: number;\r\n    ref: React.Ref<InfoRef>;\r\n    onScroll: (info: {\r\n        currentTarget?: HTMLElement;\r\n        scrollLeft?: number;\r\n    }) => void;\r\n}\r\n\r\nexport interface ScrollViewSize {\r\n    x: number,\r\n    y: number\r\n}\r\n\r\nexport interface ScrollConfig extends ScrollViewSize {\r\n    scrollToFirstRowOnChange?: boolean;\r\n}\r\n\r\nexport interface ColumnType<RecordType extends Record<any, any> = any> extends Omit<AntdTableColumnType<RecordType>, \"width\" | \"shouldCellUpdate\" | \"onCell\" | \"render\"> {\r\n    overlap?: number,\r\n    width: number,\r\n    onCell?: (data: RecordType | undefined, index?: number, isScrolling?: boolean) => React.HTMLAttributes<any> | React.TdHTMLAttributes<any>;\r\n    render?: (value: any, record: RecordType | undefined, index: number, isScrolling?: boolean) => React.ReactNode;\r\n    shouldCellUpdate?: (record: RecordType | undefined, prevRecord: RecordType | undefined, isScrolling?: boolean) => boolean;\r\n}\r\n\r\nexport type ColumnsType<RecordType extends Record<any, any> = any> = ColumnType<RecordType>[];\r\n\r\nexport type VirtualTableComponents<RecordType> = Omit<TableComponents<RecordType>, \"body\">;\r\n\r\nexport interface VirtualTableProps<RecordType extends Record<any, any>> extends Omit<TableProps<RecordType>, \"columns\" | \"scroll\" | \"components\"> {\r\n    components?: VirtualTableComponents<RecordType>,\r\n    gridRef?: React.Ref<Grid<RecordType>>,\r\n    outerGridRef?: React.Ref<HTMLElement>,\r\n    scroll: ScrollConfig,\r\n    columns: ColumnsType<RecordType>,\r\n    rowHeight: number | ((record: Readonly<RecordType>) => number),\r\n    rerenderFixedColumnOnHorizontalScroll?: boolean,\r\n    onScroll?: OnScrollCallback,\r\n}\r\n\r\nexport const VirtualTable = <RecordType extends Record<any, any>>(props: VirtualTableProps<RecordType> & { ref?: Ref<HTMLDivElement> }) => {\r\n\r\n    const {\r\n        ref,\r\n        dataSource,\r\n        className,\r\n        columns,\r\n        rowHeight,\r\n        scroll,\r\n        gridRef,\r\n        outerGridRef,\r\n        onScroll,\r\n        onChange,\r\n        components,\r\n        locale,\r\n        showHeader,\r\n        rerenderFixedColumnOnHorizontalScroll,\r\n        ...tableProps\r\n    } = props;\r\n\r\n    const tableRef = useRef<HTMLElement | null>(null);\r\n    const internalGridRef = useRef<Grid<RecordType> | null>(null);\r\n    const [connectObject] = useState<InfoRef>(() => {\r\n\r\n        return {\r\n\r\n            get scrollLeft() {\r\n\r\n                if (internalGridRef.current) {\r\n                    return internalGridRef.current?.state.scrollLeft;\r\n                }\r\n\r\n                return 0;\r\n            },\r\n\r\n            set scrollLeft(value: number) {\r\n\r\n                if (internalGridRef.current) {\r\n\r\n                    const currentScrollLeft = internalGridRef.current.state.scrollLeft;\r\n\r\n                    if(currentScrollLeft == value) {\r\n                        return;\r\n                    }\r\n\r\n                    internalGridRef.current.scrollTo({ scrollLeft: value });\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n    const fixStickyHeaderOffset = useCallback((tableWrap?: HTMLElement | null, maxWidth: number = -1) => {\r\n\r\n        // Данная функция нужна для поддержки overlap свойства колонки\r\n        // Исправляем смещение для sticky колонок\r\n        // Так же исправим баг связанный с таблицей\r\n\r\n        if(showHeader === false || components?.header) {\r\n            return;\r\n        }\r\n\r\n        if(tableWrap) {\r\n\r\n            const header = tableWrap.querySelector<HTMLElement>(\".ant-table .ant-table-header\");\r\n\r\n            if (header) {\r\n\r\n                const headerCells = header.querySelectorAll<HTMLTableCellElement>(\".ant-table-thead .ant-table-cell\");\r\n\r\n                /*\r\n                let totalWidth = 0;\r\n                for(let headerIndex = 0; headerIndex < headerCells.length; headerIndex++) {\r\n                    const cell = headerCells[headerIndex];\r\n                    const width = cell.getBoundingClientRect().width;\r\n                    totalWidth += width;\r\n                }\r\n                */\r\n                \r\n                // TODO: Возможно пользователь задал свое значение, тут надо подумать...\r\n                // Если размер блока грида, меньше длины \r\n                if (maxWidth !== -1) {\r\n                    header.style.maxWidth = `${maxWidth}px`;\r\n                } else {\r\n                    header.style.removeProperty(\"maxWidth\");\r\n                }\r\n\r\n                let leftOffset = 0;\r\n                let rightOffset = 0;\r\n\r\n                for(let headerIndex = 0; headerIndex < headerCells.length; headerIndex++) {\r\n\r\n                    const cell = headerCells[headerIndex];\r\n\r\n                    if (cell.classList.contains(\"ant-table-cell-fix-left\")) {\r\n                        const width = cell.getBoundingClientRect().width;\r\n                        cell.style.left = `${leftOffset}px`;\r\n                        leftOffset += width;\r\n                        continue;\r\n                    }\r\n\r\n                    break;\r\n                }\r\n\r\n                for(let headerIndex = headerCells.length - 1; headerIndex > -1; headerIndex--) {\r\n\r\n                    const cell = headerCells[headerIndex];\r\n\r\n                    if (cell.classList.contains(\"ant-table-cell-fix-right\")) {\r\n                        const width = cell.getBoundingClientRect().width;\r\n                        cell.style.right = `${rightOffset}px`;\r\n                        rightOffset += width;\r\n                        continue;\r\n                    }\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        \r\n    }, [components?.header,\r\n        showHeader\r\n    ]);\r\n\r\n    const reset = useCallback((columnIndex: number = 0, rowIndex: number = 0) => {\r\n\r\n        if(scroll.scrollToFirstRowOnChange) {\r\n            connectObject.scrollLeft = 0;\r\n        }\r\n\r\n        internalGridRef.current?.resetAfterIndices({\r\n            columnIndex: columnIndex,\r\n            rowIndex: rowIndex,\r\n            shouldForceUpdate: true,\r\n        });\r\n\r\n        fixStickyHeaderOffset(tableRef.current);\r\n\r\n    }, [scroll.scrollToFirstRowOnChange, connectObject, fixStickyHeaderOffset]);\r\n\r\n    const handleChange = useCallback<NonNullable<typeof onChange>>((pagination, filters, sorter, extra) => {\r\n\r\n        if(onChange) {\r\n            onChange(pagination, filters, sorter, extra);\r\n        }\r\n\r\n        if(scroll.scrollToFirstRowOnChange) {\r\n            reset();\r\n        }\r\n        else {\r\n            fixStickyHeaderOffset(tableRef.current);\r\n        }\r\n\r\n    }, [scroll.scrollToFirstRowOnChange,\r\n        onChange,\r\n        reset,\r\n        fixStickyHeaderOffset\r\n    ]);\r\n\r\n    const [normalizeColumns, normalizeIndexes, getColumn, cellRender] = useMemo(() => {\r\n\r\n        let blockBuffer = 0;\r\n\r\n        const normalizeColumns: typeof columns = [];\r\n        const normalizeIndexes: number[] = [];\r\n\r\n        columns.forEach((column, index) => {\r\n            \r\n            if(blockBuffer > 1) {\r\n                blockBuffer--;\r\n                return;\r\n            }\r\n\r\n            blockBuffer = column.overlap ?? 0;\r\n\r\n            normalizeColumns.push(column);\r\n            normalizeIndexes.push(index);\r\n        });\r\n\r\n        const getColumn = (index: number) => normalizeColumns[index];\r\n        const cellRender = (props: GridChildComponentProps<RecordType>) => {\r\n\r\n            const { columnIndex } = props;\r\n            const originalColumnIndex = normalizeIndexes[columnIndex];\r\n            const column = normalizeColumns[columnIndex];\r\n\r\n            return (\r\n                <MemonableVirtualTableCell\r\n                    {...props}\r\n                    originalColumnIndex={originalColumnIndex}\r\n                    column={column}\r\n                />\r\n            );\r\n        };\r\n\r\n        return [\r\n            normalizeColumns,\r\n            normalizeIndexes,\r\n            getColumn,\r\n            cellRender\r\n        ]; \r\n\r\n    }, [columns]);\r\n\r\n    const rowHeightGetterByRecord = useMemo(\r\n        () => isFunction(rowHeight) ? rowHeight : () => rowHeight,\r\n        [rowHeight]\r\n    );\r\n\r\n    const { renderEmpty } = React.useContext(ConfigProvider.ConfigContext);\r\n\r\n    const emptyNode = useMemo(() => {\r\n\r\n        const emptyText = (locale && locale.emptyText) || renderEmpty?.('Table') || (\r\n            <Empty\r\n                image={Empty.PRESENTED_IMAGE_SIMPLE}\r\n            />\r\n        );\r\n\r\n        const emptyNode = typeof emptyText === 'function'\r\n                        ? emptyText()\r\n                        : emptyText;\r\n\r\n        return (\r\n            <div className=\"virtual-grid-empty\">\r\n                {emptyNode}\r\n            </div>\r\n        )\r\n\r\n    }, [locale?.emptyText,\r\n        renderEmpty\r\n    ]);\r\n\r\n    const bodyRender = useCallback((rawData: readonly RecordType[], info: Info) => {\r\n\r\n        const { ref, scrollbarSize, onScroll: tableOnScroll } = info;\r\n\r\n        assignRef(connectObject, ref);\r\n\r\n        const rowHeightGetter = (index: number) => rowHeightGetterByRecord(rawData[index]);\r\n\r\n        const totalHeight = sumRowsHeights(rowHeightGetter, rawData, rawData.length - 1);\r\n\r\n        const columnWidthGetter = (index: number): number => {\r\n\r\n            const column = normalizeColumns[index];\r\n            const { width, overlap } = column;\r\n    \r\n            if(overlap && overlap > 0) {\r\n    \r\n                let blockedWidth = width;\r\n                let lastBlockedIndex = normalizeIndexes[index];\r\n\r\n                for(let overlapIndex = 1; overlapIndex < overlap; overlapIndex++) {\r\n                    lastBlockedIndex++;\r\n                    blockedWidth += columns[lastBlockedIndex].width;\r\n                }\r\n                \r\n                return lastBlockedIndex === columns.length - 1\r\n                ? blockedWidth - scrollbarSize\r\n                : blockedWidth;\r\n            }\r\n    \r\n            return totalHeight >= scroll.y && index === normalizeColumns.length - 1\r\n            ? width - scrollbarSize\r\n            : width;\r\n        }\r\n\r\n        const totalWidth  = sumColumnWidths(columnWidthGetter, normalizeColumns.length - 1);\r\n        const scrollBarOffset = totalHeight >= scroll.y ? scrollbarSize : 0;\r\n        \r\n        fixStickyHeaderOffset(tableRef.current, totalWidth + scrollBarOffset);\r\n\r\n        const handleScroll = (props: OnScrollProps) => {\r\n\r\n            if(tableOnScroll) {\r\n                tableOnScroll({\r\n                    scrollLeft: props.scrollLeft\r\n                });\r\n            }\r\n\r\n            if(onScroll) {\r\n                onScroll(props);\r\n            }\r\n        }\r\n\r\n        const hasData = rawData.length > 0;\r\n        \r\n        return (\r\n            <div className=\"virtual-grid-wrap\">\r\n                {!hasData && emptyNode}\r\n                <Grid<RecordType>\r\n                    useIsScrolling\r\n                    ref={refSetter(gridRef, internalGridRef)}\r\n                    outerRef={refSetter(outerGridRef)}\r\n                    className=\"virtual-grid\"\r\n                    rerenderFixedColumnOnHorizontalScroll={rerenderFixedColumnOnHorizontalScroll}\r\n                    estimatedColumnWidth={totalWidth / normalizeColumns.length}\r\n                    estimatedRowHeight={totalHeight / rawData.length}\r\n                    width={scroll.x}\r\n                    height={scroll.y}\r\n                    columnCount={normalizeColumns.length}\r\n                    rowCount={rawData.length}\r\n                    rowHeight={rowHeightGetter}\r\n                    columnWidth={columnWidthGetter}\r\n                    itemData={rawData}\r\n                    columnGetter={getColumn}\r\n                    onScroll={handleScroll}\r\n                >\r\n                    {cellRender}\r\n                </Grid>\r\n            </div>\r\n        );\r\n\r\n    }, [fixStickyHeaderOffset,\r\n        rowHeightGetterByRecord,\r\n        rerenderFixedColumnOnHorizontalScroll,\r\n        normalizeIndexes,\r\n        normalizeColumns,\r\n        columns,\r\n        scroll.x,\r\n        scroll.y,\r\n        getColumn,\r\n        onScroll,\r\n        cellRender,\r\n        emptyNode\r\n    ]);\r\n\r\n    useEffect(() => {\r\n        fixStickyHeaderOffset(tableRef.current)\r\n    }, [fixStickyHeaderOffset,\r\n        scroll.x,\r\n        scroll.y,\r\n        scroll.scrollToFirstRowOnChange,\r\n        columns,\r\n        showHeader,\r\n        components?.header\r\n    ]);\r\n\r\n    return (\r\n        <Table<RecordType>\r\n            {...tableProps}\r\n            ref={(el) => {\r\n                assignRef(el, ref, tableRef);\r\n                fixStickyHeaderOffset(el);\r\n            }}\r\n            locale={locale}\r\n            showHeader={showHeader}\r\n            className={classNames(\"virtual-table\", className)}\r\n            columns={columns}\r\n            dataSource={dataSource}\r\n            scroll={scroll}\r\n            components={{\r\n                ...components,\r\n                body: bodyRender,\r\n            }}\r\n            onChange={handleChange}\r\n        />\r\n    );\r\n}\r\n\r\nexport default VirtualTable;"],"names":["size","getScrollbarSize","recalculate","div","document","createElement","style","width","height","overflow","body","appendChild","offsetWidth","clientWidth","removeChild","isFunction","value","toString","call","assignRef","refValue","refs","i","length","tmpRef","current","refSetter","ref","hasOwn","hasOwnProperty","classNames","args","classes","arguments","arg","argType","push","Array","isArray","inner","apply","Object","prototype","includes","key","join","fastDeepEqual","equal","a","b","constructor","keys","RegExp","source","flags","valueOf","columnRowClassName","defaultItemKey","columnIndex","data","rowIndex","MemonableVirtualTableCell","memo","props","column","originalColumnIndex","isScrolling","row","dataIndex","undefined","cellProps","onCell","render","content","React","className","prevProps","nextProps","shouldCellUpdate","prevRecord","getEstimatedTotalHeight","rowCount","rowMetadataMap","estimatedRowHeight","lastMeasuredRowIndex","totalSizeOfMeasuredRows","itemMetadata","offset","getEstimatedTotalWidth","columnCount","columnMetadataMap","estimatedColumnWidth","lastMeasuredColumnIndex","getOffsetForIndexAndAlignment","itemType","index","align","scrollOffset","instanceProps","scrollbarSize","sumOfLeftFixedColumnsWidth","sumOfRightFixedColumnsWidth","leftOffset","rightOffset","itemMetadataMap","itemSize","lastMeasuredIndex","columnWidth","rowHeight","getItemMetadata","estimatedTotalSize","maxOffset","Math","max","min","minOffset","round","getOffsetForColumnAndAlignment","getOffsetForRowAndAlignment","_extends","assign","bind","target","this","_assertThisInitialized","self","ReferenceError","_setPrototypeOf","o","p","setPrototypeOf","__proto__","safeIsNaN","Number","isNaN","areInputsEqual","newInputs","lastInputs","first","second","memoizeOne","resultFn","isEqual","lastThis","lastResult","lastArgs","calledOnce","newArgs","_i","now","performance","Date","cancelTimeout","timeoutID","cancelAnimationFrame","id","cachedRTLResult","getRTLOffsetType","outerDiv","outerStyle","direction","innerDiv","innerStyle","scrollLeft","IS_SCROLLING_DEBOUNCE_INTERVAL","_ref","devWarningsOverscanCount","devWarningsOverscanRowsColumnsCount","devWarningsTagName","createGridComponent","_ref2","_class","getColumnOffset","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getColumnWidth","getRowHeight","getRowOffset","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","_PureComponent","subClass","superClass","Grid","_this","_instanceProps","_resetIsScrollingTimeoutId","_outerRef","state","instance","horizontalScrollDirection","initialScrollLeft","scrollTop","initialScrollTop","scrollUpdateWasRequested","verticalScrollDirection","_callOnItemsRendered","overscanColumnStartIndex","overscanColumnStopIndex","overscanRowStartIndex","overscanRowStopIndex","visibleColumnStartIndex","visibleColumnStopIndex","visibleRowStartIndex","visibleRowStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","_this$props","itemStyleCache","_getItemStyleCache","_offset","isRtl","position","left","right","top","_","__","___","_onScroll","event","_event$currentTarget","currentTarget","clientHeight","scrollHeight","scrollWidth","setState","prevState","calculatedScrollLeft","calculatedScrollTop","_resetIsScrollingDebounced","_outerRefSetter","outerRef","callback","delay","start","_resetIsScrolling","requestAnimationFrame","tick","create","getDerivedStateFromProps","validateSharedProps","_proto","scrollTo","_ref3","scrollToItem","_ref4","_ref4$align","_this$props2","_this$state","estimatedTotalHeight","horizontalScrollbarSize","verticalScrollbarSize","componentDidMount","_this$props3","_callPropsCallbacks","componentDidUpdate","_this$state2","componentWillUnmount","_this$props4","children","innerRef","innerElementType","innerTagName","itemData","_this$props4$itemKey","itemKey","outerElementType","outerTagName","useIsScrolling","_this$_getHorizontalR","_getHorizontalRangeToRender","columnStartIndex","columnStopIndex","_this$_getVerticalRan","_getVerticalRangeToRender","rowStartIndex","rowStopIndex","items","_rowIndex","_columnIndex","estimatedTotalWidth","WebkitOverflowScrolling","willChange","pointerEvents","_this$props5","_this$_getHorizontalR2","_overscanColumnStartIndex","_overscanColumnStopIndex","_visibleColumnStartIndex","_visibleColumnStopIndex","_this$_getVerticalRan2","_overscanRowStartIndex","_overscanRowStopIndex","_visibleRowStartIndex","_visibleRowStopIndex","_this$state3","_horizontalScrollDirection","_scrollLeft","_scrollTop","_scrollUpdateWasRequested","_verticalScrollDirection","_this$props6","overscanColumnCount","overscanColumnsCount","overscanCount","_this$state4","overscanCountResolved","startIndex","stopIndex","overscanBackward","overscanForward","_this$props7","overscanRowCount","overscanRowsCount","_this$state5","PureComponent","defaultProps","process","env","NODE_ENV","window","WeakSet","_ref5","_ref6","has","add","console","warn","Error","findNearestItem","findNearestItemBinarySearch","findNearestItemExponentialSearch","high","low","middle","floor","currentOffset","itemCount","interval","VariableSizeGrid","resetAfterColumnIndex","shouldForceUpdate","resetAfterIndices","resetAfterRowIndex","_ref6$shouldForceUpda","forceUpdate","_ref7","super","_leftFixedColumnsWidth","_rightFixedColumnsWidth","_firstUnFixedColumn","_firstRightFixedColumn","_updateFixedColumnsVars","columnGetter","_lastFixedRenderedContent","_lastFixedRenderedRowStartIndex","_lastFixedRenderedRowStopIndex","fixed","_renderFixedColumns","update","rerenderFixedColumnOnHorizontalScroll","rows","shownRowsCount","visibleRowIndex","rowLeftColumns","rowRightColumns","renderFixedColumn","item","rowClassName","onRow","rowKey","rowsColumns","rowsElementProps","rowsFixedColumns","record","divProps","firstItemStyle","firstUnFixedColumn","firstRightFixedColumn","rowColumns","entries","map","rowFixedColumns","fixedLeftColumns","fixedRightColumns","columns","values","hasFixedLeftColumn","hasFixedRightColumn","snapshot","VirtualTable","dataSource","scroll","gridRef","outerGridRef","onChange","components","locale","showHeader","tableProps","tableRef","useRef","internalGridRef","connectObject","useState","fixStickyHeaderOffset","useCallback","tableWrap","maxWidth","header","querySelector","headerCells","querySelectorAll","removeProperty","headerIndex","cell","classList","contains","getBoundingClientRect","reset","scrollToFirstRowOnChange","handleChange","pagination","filters","sorter","extra","normalizeColumns","normalizeIndexes","getColumn","cellRender","useMemo","blockBuffer","forEach","overlap","rowHeightGetterByRecord","renderEmpty","useContext","ConfigProvider","ConfigContext","emptyNode","emptyText","Empty","image","PRESENTED_IMAGE_SIMPLE","bodyRender","rawData","info","tableOnScroll","rowHeightGetter","totalHeight","sum","sumRowsHeights","columnWidthGetter","blockedWidth","lastBlockedIndex","overlapIndex","y","totalWidth","sumColumnWidths","scrollBarOffset","hasData","x","useEffect","Table","el"],"mappings":"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","x_google_ignoreList":[2,5,6,7,8,9,10]}