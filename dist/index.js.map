{"version":3,"file":"index.js","sources":["../src/src/dom-helpers.ts","../src/src/helpers.ts","../node_modules/fast-deep-equal/index.js","../src/src/cell.tsx","../node_modules/@babel/runtime/helpers/esm/extends.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/memoize-one/dist/memoize-one.esm.js","../node_modules/react-window/dist/index.esm.js","../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","../src/react-window-grid.js","../src/src/grid-helpers.ts","../src/src/grid.tsx","../src/src/table.tsx"],"sourcesContent":["let size: number = -1;\r\n\r\n// This utility copied from \"dom-helpers\" package.\r\nexport function getScrollbarSize(recalculate: boolean = false): number {\r\n\r\n    if (size === -1 || recalculate) {\r\n\r\n        const div = document.createElement('div');\r\n        const style = div.style;\r\n\r\n        style.width = '50px';\r\n        style.height = '50px';\r\n        style.overflow = 'scroll';\r\n  \r\n        document.body.appendChild(div);\r\n  \r\n        size = div.offsetWidth - div.clientWidth;\r\n  \r\n        document.body.removeChild(div);\r\n    }\r\n  \r\n    return size;\r\n}\r\n\r\nexport type RTLOffsetType =\r\n  | 'negative'\r\n  | 'positive-descending'\r\n  | 'positive-ascending';\r\n\r\nlet cachedRTLResult: RTLOffsetType | null = null;\r\n\r\n// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\r\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\r\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\r\n// The safest way to check this is to intentionally set a negative offset,\r\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\r\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\r\nexport function getRTLOffsetType(recalculate: boolean = false): RTLOffsetType {\r\n\r\n    if (cachedRTLResult === null || recalculate) {\r\n        const outerDiv = document.createElement('div');\r\n        const outerStyle = outerDiv.style;\r\n        outerStyle.width = '50px';\r\n        outerStyle.height = '50px';\r\n        outerStyle.overflow = 'scroll';\r\n        outerStyle.direction = 'rtl';\r\n\r\n        const innerDiv = document.createElement('div');\r\n        const innerStyle = innerDiv.style;\r\n        innerStyle.width = '100px';\r\n        innerStyle.height = '100px';\r\n\r\n        outerDiv.appendChild(innerDiv);\r\n\r\n        document.body.appendChild(outerDiv);\r\n\r\n        if (outerDiv.scrollLeft > 0) {\r\n            cachedRTLResult = 'positive-descending';\r\n        } else {\r\n            outerDiv.scrollLeft = 1;\r\n            if (outerDiv.scrollLeft === 0) {\r\n                cachedRTLResult = 'negative';\r\n            } else {\r\n                cachedRTLResult = 'positive-ascending';\r\n            }\r\n        }\r\n\r\n        document.body.removeChild(outerDiv);\r\n\r\n        return cachedRTLResult;\r\n    }\r\n\r\n    return cachedRTLResult;\r\n}","export type ValueGetter<T = number> = T | ((index: number) => T);\r\n\r\nexport function isFunction(value: any): value is Function {\r\n    return typeof value === 'function'\r\n        || (value && {}.toString.call(value) === '[object Function]');\r\n}\r\n\r\nexport function isArray<T>(value: T[]): value is T[]\r\nexport function isArray<T>(value: Array<T>): value is Array<T>\r\nexport function isArray<T>(value: T | T[]): value is Array<T>\r\nexport function isArray<T>(value: Readonly<T[]>): value is Readonly<T[]>\r\nexport function isArray<T>(value: Readonly<Array<T>>): value is Readonly<Array<T>>\r\nexport function isArray<T>(value: T | Readonly<T[]>): value is Readonly<Array<T>>\r\nexport function isArray(value: unknown): value is Array<unknown>\r\nexport function isArray(value: unknown): value is Array<unknown> {\r\n    return Array.isArray(value);\r\n}\r\n\r\nexport function sumColumnWidths(columnWidthGetter: ValueGetter<number>, index: number) {\r\n\r\n    if (index < 0) {\r\n        return 0;\r\n    }\r\n\r\n    if(isFunction(columnWidthGetter)) {\r\n        let sum = 0;\r\n        while (index-- > 0) {\r\n            sum += columnWidthGetter(index);\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    return columnWidthGetter + (index * columnWidthGetter);\r\n}\r\n\r\n\r\nexport function sumRowsHeights<T>(rowHeightGetter: ValueGetter<number>, rows: ReadonlyArray<T>, index: number) {\r\n\r\n    if (index < 0) {\r\n        return 0;\r\n    }\r\n\r\n    if(isFunction(rowHeightGetter)) {\r\n\r\n        let sum = 0;\r\n        \r\n        for(; index > -1; index--) {\r\n            sum += rowHeightGetter(index);\r\n        }\r\n\r\n        return sum;\r\n    }\r\n    \r\n    return index * rowHeightGetter;\r\n}\r\n\r\nexport function assignRef<T>(refValue: T, ...refs: (React.Ref<T> | undefined)[]) {\r\n\r\n    for(let i = 0; i < refs.length; i++) {\r\n\r\n        const tmpRef = refs[i];\r\n\r\n        if(typeof tmpRef === 'function') { tmpRef(refValue); }\r\n        if(typeof tmpRef === 'object')   { (tmpRef as unknown as React.MutableRefObject<T>).current = refValue; }\r\n    }\r\n}\r\n\r\nexport function refSetter<T>(...refs: (React.Ref<T> | undefined)[]) {\r\n    return (ref: T) => assignRef(ref, ...refs);\r\n}\r\n\r\nexport function mixClassNameSingle(classList1: string, classList2: string | undefined) {\r\n    return classList1 + (classList2 ? \" \" + classList2 : '');\r\n}\r\n\r\nexport const hasOwn = {}.hasOwnProperty;\r\n\r\nexport type ClassNamesValue = string | number | boolean | undefined | null;\r\nexport type ClassNamesMapping = Record<string, unknown>;\r\nexport type ClassNamesArgument = ClassNamesValue | ClassNamesMapping | ClassNamesArgumentArray;\r\nexport interface ClassNamesArgumentArray extends Array<ClassNamesArgument> {}\r\n\r\nexport function classNames(...args: ClassNamesArgumentArray) {\r\n\r\n    const classes: string[] = [];\r\n\r\n    for (let i = 0; i < arguments.length; i++) {\r\n\r\n        const arg = arguments[i];\r\n\r\n        if (!arg) continue;\r\n\r\n        const argType = typeof arg;\r\n\r\n        if (argType === 'string' || argType === 'number') {\r\n\r\n            classes.push(arg);\r\n\r\n        } else if (Array.isArray(arg)) {\r\n\r\n            if (arg.length) {\r\n\r\n                const inner = classNames.apply(null, arg);\r\n\r\n                if (inner) {\r\n                    classes.push(inner);\r\n                }\r\n            }\r\n\r\n        } else if (argType === 'object') {\r\n\r\n            if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {\r\n\r\n                classes.push(arg.toString());\r\n                continue;\r\n            }\r\n\r\n            for (var key in arg) {\r\n\r\n                if (hasOwn.call(arg, key) && arg[key]) {\r\n\r\n                    classes.push(key);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return classes.join(' ');\r\n}","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","import equal from 'fast-deep-equal';\r\nimport React, { memo } from 'react';\r\nimport { GridChildComponentProps as OriginalGridChildComponentProps } from 'react-window';\r\nimport { classNames } from './helpers';\r\nimport { ColumnType } from './table';\r\n\r\nexport const columnRowClassName = \"virtial-grid-item\";\r\n\r\nexport const defaultItemKey = <TData,>({ columnIndex, data, rowIndex }: { columnIndex: number, data: TData | undefined, rowIndex: number }) =>\r\n  `${rowIndex}:${columnIndex}`;\r\n\r\nexport interface GridChildComponentProps<RecordType extends Record<any, any> = any> extends OriginalGridChildComponentProps<readonly RecordType[]> {\r\n}\r\n\r\nexport interface VirtualTableCellProps<RecordType extends Record<any, any> = any> extends GridChildComponentProps<RecordType> {\r\n    originalColumnIndex: number,\r\n    column: ColumnType<RecordType>\r\n}\r\n\r\nexport function VirtualTableCell<RecordType extends Record<any, any> = any>(props: VirtualTableCellProps<RecordType>) {\r\n\r\n    const { style, column, data, originalColumnIndex, columnIndex, rowIndex, isScrolling } = props;\r\n\r\n    const row       = data && data[rowIndex];\r\n    const value     = column.dataIndex && row ? row[column.dataIndex as any] : undefined;\r\n    const cellProps = column.onCell && column.onCell(row, columnIndex, isScrolling);\r\n    const render    = column.render;\r\n    const content   = render ?\r\n                      render(value, row, columnIndex, isScrolling) :\r\n                      value as unknown as React.ReactNode;\r\n    \r\n    return (\r\n        <div\r\n            {...cellProps}\r\n            data-row-index={rowIndex}\r\n            data-column-index={columnIndex}\r\n            data-original-column-index={originalColumnIndex}\r\n            style={{\r\n                ...cellProps?.style,\r\n                ...style\r\n            }}\r\n            className={classNames(columnRowClassName, cellProps?.className)}\r\n        >\r\n            {content}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport const MemonableVirtualTableCell = memo(VirtualTableCell, (prevProps, nextProps) => {\r\n\r\n    // system index\r\n    if(prevProps.originalColumnIndex !== nextProps.originalColumnIndex\r\n    || prevProps.columnIndex         !== nextProps.columnIndex\r\n    || prevProps.rowIndex            !== nextProps.rowIndex) {\r\n        return false;\r\n    }\r\n\r\n    if (prevProps.style !== nextProps.style\r\n    && !equal(prevProps.style, nextProps.style)) {\r\n        return false;\r\n    }\r\n\r\n    // check handler\r\n    const shouldCellUpdate = nextProps.column.shouldCellUpdate;\r\n\r\n    if(shouldCellUpdate) {\r\n\r\n        const prevRecord  = prevProps.data;\r\n        const nextRecord  = nextProps.data;\r\n        const isScrolling = nextProps.isScrolling;\r\n\r\n        if(!shouldCellUpdate(nextRecord, prevRecord, isScrolling)) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    if(prevProps.data             === nextProps.data\r\n    && prevProps.column.dataIndex === nextProps.column.dataIndex\r\n    && prevProps.column.onCell    === nextProps.column.onCell\r\n    && prevProps.column.render    === nextProps.column.render) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n});","export default function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}","var safeIsNaN = Number.isNaN ||\n    function ponyfill(value) {\n        return typeof value === 'number' && value !== value;\n    };\nfunction isEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    if (safeIsNaN(first) && safeIsNaN(second)) {\n        return true;\n    }\n    return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (!isEqual(newInputs[i], lastInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\nexport default memoizeOne;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\nvar now = hasNativePerformanceNow ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nfunction cancelTimeout(timeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay) {\n  var start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  var timeoutID = {\n    id: requestAnimationFrame(tick)\n  };\n  return timeoutID;\n}\n\nvar size = -1; // This utility copied from \"dom-helpers\" package.\n\nfunction getScrollbarSize(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (size === -1 || recalculate) {\n    var div = document.createElement('div');\n    var style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n    document.body.appendChild(div);\n    size = div.offsetWidth - div.clientWidth;\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\nvar cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\n\nfunction getRTLOffsetType(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (cachedRTLResult === null || recalculate) {\n    var outerDiv = document.createElement('div');\n    var outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n    var innerDiv = document.createElement('div');\n    var innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nvar defaultItemKey = function defaultItemKey(_ref) {\n  var columnIndex = _ref.columnIndex,\n      data = _ref.data,\n      rowIndex = _ref.rowIndex;\n  return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsOverscanCount = null;\nvar devWarningsOverscanRowsColumnsCount = null;\nvar devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = /*#__PURE__*/new WeakSet();\n    devWarningsOverscanRowsColumnsCount = /*#__PURE__*/new WeakSet();\n    devWarningsTagName = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createGridComponent(_ref2) {\n  var _class;\n\n  var getColumnOffset = _ref2.getColumnOffset,\n      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,\n      getColumnWidth = _ref2.getColumnWidth,\n      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,\n      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,\n      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,\n      getRowHeight = _ref2.getRowHeight,\n      getRowOffset = _ref2.getRowOffset,\n      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,\n      initInstanceProps = _ref2.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref2.validateProps;\n  return _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(Grid, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function Grid(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._resetIsScrollingTimeoutId = null;\n      _this._outerRef = void 0;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        horizontalScrollDirection: 'forward',\n        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,\n        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,\n        scrollUpdateWasRequested: false,\n        verticalScrollDirection: 'forward'\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanColumnStartIndex: overscanColumnStartIndex,\n          overscanColumnStopIndex: overscanColumnStopIndex,\n          overscanRowStartIndex: overscanRowStartIndex,\n          overscanRowStopIndex: overscanRowStopIndex,\n          visibleColumnStartIndex: visibleColumnStartIndex,\n          visibleColumnStopIndex: visibleColumnStopIndex,\n          visibleRowStartIndex: visibleRowStartIndex,\n          visibleRowStopIndex: visibleRowStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          horizontalScrollDirection: horizontalScrollDirection,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          verticalScrollDirection: verticalScrollDirection,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (rowIndex, columnIndex) {\n        var _this$props = _this.props,\n            columnWidth = _this$props.columnWidth,\n            direction = _this$props.direction,\n            rowHeight = _this$props.rowHeight;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n\n        var key = rowIndex + \":\" + columnIndex;\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(key)) {\n          style = itemStyleCache[key];\n        } else {\n          var _offset = getColumnOffset(_this.props, columnIndex, _this._instanceProps);\n\n          var isRtl = direction === 'rtl';\n          itemStyleCache[key] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : _offset,\n            right: isRtl ? _offset : undefined,\n            top: getRowOffset(_this.props, rowIndex, _this._instanceProps),\n            height: getRowHeight(_this.props, rowIndex, _this._instanceProps),\n            width: getColumnWidth(_this.props, columnIndex, _this._instanceProps)\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScroll = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientHeight = _event$currentTarget.clientHeight,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollTop = _event$currentTarget.scrollTop,\n            scrollHeight = _event$currentTarget.scrollHeight,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n\n          var calculatedScrollLeft = scrollLeft;\n\n          if (direction === 'rtl') {\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                calculatedScrollLeft = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));\n          var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n            scrollLeft: calculatedScrollLeft,\n            scrollTop: calculatedScrollTop,\n            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1);\n        });\n      };\n\n      return _this;\n    }\n\n    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = Grid.prototype;\n\n    _proto.scrollTo = function scrollTo(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(function (prevState) {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(_ref4) {\n      var _ref4$align = _ref4.align,\n          align = _ref4$align === void 0 ? 'auto' : _ref4$align,\n          columnIndex = _ref4.columnIndex,\n          rowIndex = _ref4.rowIndex;\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          height = _this$props2.height,\n          rowCount = _this$props2.rowCount,\n          width = _this$props2.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n      var scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n\n      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n      this.scrollTo({\n        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n      });\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          initialScrollLeft = _this$props3.initialScrollLeft,\n          initialScrollTop = _this$props3.initialScrollTop;\n\n      if (this._outerRef != null) {\n        var outerRef = this._outerRef;\n\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var direction = this.props.direction;\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollTop = _this$state2.scrollTop,\n          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        var outerRef = this._outerRef;\n\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n\n            default:\n              var clientWidth = outerRef.clientWidth,\n                  scrollWidth = outerRef.scrollWidth;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          columnCount = _this$props4.columnCount,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          rowCount = _this$props4.rowCount,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),\n          columnStartIndex = _this$_getHorizontalR[0],\n          columnStopIndex = _this$_getHorizontalR[1];\n\n      var _this$_getVerticalRan = this._getVerticalRangeToRender(),\n          rowStartIndex = _this$_getVerticalRan[0],\n          rowStopIndex = _this$_getVerticalRan[1];\n\n      var items = [];\n\n      if (columnCount > 0 && rowCount) {\n        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {\n          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {\n            items.push(createElement(children, {\n              columnIndex: _columnIndex,\n              data: itemData,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              key: itemKey({\n                columnIndex: _columnIndex,\n                data: itemData,\n                rowIndex: _rowIndex\n              }),\n              rowIndex: _rowIndex,\n              style: this._getItemStyle(_rowIndex, _columnIndex)\n            }));\n          }\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: this._onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalHeight,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: estimatedTotalWidth\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      var _this$props5 = this.props,\n          columnCount = _this$props5.columnCount,\n          onItemsRendered = _this$props5.onItemsRendered,\n          onScroll = _this$props5.onScroll,\n          rowCount = _this$props5.rowCount;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),\n              _overscanColumnStartIndex = _this$_getHorizontalR2[0],\n              _overscanColumnStopIndex = _this$_getHorizontalR2[1],\n              _visibleColumnStartIndex = _this$_getHorizontalR2[2],\n              _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n\n          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),\n              _overscanRowStartIndex = _this$_getVerticalRan2[0],\n              _overscanRowStopIndex = _this$_getVerticalRan2[1],\n              _visibleRowStartIndex = _this$_getVerticalRan2[2],\n              _visibleRowStopIndex = _this$_getVerticalRan2[3];\n\n          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        var _this$state3 = this.state,\n            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,\n            _scrollLeft = _this$state3.scrollLeft,\n            _scrollTop = _this$state3.scrollTop,\n            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,\n            _verticalScrollDirection = _this$state3.verticalScrollDirection;\n\n        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n      var _this$props6 = this.props,\n          columnCount = _this$props6.columnCount,\n          overscanColumnCount = _this$props6.overscanColumnCount,\n          overscanColumnsCount = _this$props6.overscanColumnsCount,\n          overscanCount = _this$props6.overscanCount,\n          rowCount = _this$props6.rowCount;\n      var _this$state4 = this.state,\n          horizontalScrollDirection = _this$state4.horizontalScrollDirection,\n          isScrolling = _this$state4.isScrolling,\n          scrollLeft = _this$state4.scrollLeft;\n      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n      var _this$props7 = this.props,\n          columnCount = _this$props7.columnCount,\n          overscanCount = _this$props7.overscanCount,\n          overscanRowCount = _this$props7.overscanRowCount,\n          overscanRowsCount = _this$props7.overscanRowsCount,\n          rowCount = _this$props7.rowCount;\n      var _this$state5 = this.state,\n          isScrolling = _this$state5.isScrolling,\n          verticalScrollDirection = _this$state5.verticalScrollDirection,\n          scrollTop = _this$state5.scrollTop;\n      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return Grid;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    useIsScrolling: false\n  }, _class;\n}\n\nvar validateSharedProps = function validateSharedProps(_ref5, _ref6) {\n  var children = _ref5.children,\n      direction = _ref5.direction,\n      height = _ref5.height,\n      innerTagName = _ref5.innerTagName,\n      outerTagName = _ref5.outerTagName,\n      overscanColumnsCount = _ref5.overscanColumnsCount,\n      overscanCount = _ref5.overscanCount,\n      overscanRowsCount = _ref5.overscanRowsCount,\n      width = _ref5.width;\n  var instance = _ref6.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn('The overscanCount prop has been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (typeof overscanColumnsCount === 'number' || typeof overscanRowsCount === 'number') {\n      if (devWarningsOverscanRowsColumnsCount && !devWarningsOverscanRowsColumnsCount.has(instance)) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn('The overscanColumnsCount and overscanRowsCount props have been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    if (typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Grids must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    }\n\n    if (typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Grids must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n  var rowCount = _ref.rowCount;\n  var rowMetadataMap = _ref2.rowMetadataMap,\n      estimatedRowHeight = _ref2.estimatedRowHeight,\n      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n  var columnCount = _ref3.columnCount;\n  var columnMetadataMap = _ref4.columnMetadataMap,\n      estimatedColumnWidth = _ref4.estimatedColumnWidth,\n      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {\n  var itemMetadataMap, itemSize, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = props.columnWidth;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = props.rowHeight;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n  var itemMetadataMap, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n  var size = itemType === 'column' ? props.width : props.height;\n  var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n\n  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n\n    case 'end':\n      return minOffset;\n\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n\n  }\n};\n\nvar VariableSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n    return getItemMetadata('column', props, index, instanceProps).offset;\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n    return findNearestItem('column', props, instanceProps, scrollLeft);\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n    var columnCount = props.columnCount,\n        width = props.width;\n    var itemMetadata = getItemMetadata('column', props, startIndex, instanceProps);\n    var maxOffset = scrollLeft + width;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n    return instanceProps.columnMetadataMap[index].size;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getRowOffset: function getRowOffset(props, index, instanceProps) {\n    return getItemMetadata('row', props, index, instanceProps).offset;\n  },\n  getRowHeight: function getRowHeight(props, index, instanceProps) {\n    return instanceProps.rowMetadataMap[index].size;\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n    return findNearestItem('row', props, instanceProps, scrollTop);\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n    var rowCount = props.rowCount,\n        height = props.height;\n    var itemMetadata = getItemMetadata('row', props, startIndex, instanceProps);\n    var maxOffset = scrollTop + height;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref5 = props,\n        estimatedColumnWidth = _ref5.estimatedColumnWidth,\n        estimatedRowHeight = _ref5.estimatedRowHeight;\n    var instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {}\n    };\n\n    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        columnIndex: columnIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        rowIndex: rowIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterIndices = function (_ref6) {\n      var columnIndex = _ref6.columnIndex,\n          rowIndex = _ref6.rowIndex,\n          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,\n          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n      }\n\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n      } // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref7) {\n    var columnWidth = _ref7.columnWidth,\n        rowHeight = _ref7.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      } else if (typeof rowHeight !== 'function') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\n\nvar defaultItemKey$1 = function defaultItemKey(index, data) {\n  return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsDirection = null;\nvar devWarningsTagName$1 = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = /*#__PURE__*/new WeakSet();\n    devWarningsTagName$1 = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createListComponent(_ref) {\n  var _class;\n\n  var getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getItemSize = _ref.getItemSize,\n      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initInstanceProps = _ref.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref.validateProps;\n  return _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(List, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function List(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._outerRef = void 0;\n      _this._resetIsScrollingTimeoutId = null;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,\n        scrollUpdateWasRequested: false\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanStartIndex: overscanStartIndex,\n          overscanStopIndex: overscanStopIndex,\n          visibleStartIndex: visibleStartIndex,\n          visibleStopIndex: visibleStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          scrollDirection: scrollDirection,\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (index) {\n        var _this$props = _this.props,\n            direction = _this$props.direction,\n            itemSize = _this$props.itemSize,\n            layout = _this$props.layout;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n\n          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n\n          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n          var isRtl = direction === 'rtl';\n          var offsetHorizontal = isHorizontal ? _offset : 0;\n          itemStyleCache[index] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : offsetHorizontal,\n            right: isRtl ? offsetHorizontal : undefined,\n            top: !isHorizontal ? _offset : 0,\n            height: !isHorizontal ? size : '100%',\n            width: isHorizontal ? size : '100%'\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScrollHorizontal = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollLeft) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction;\n          var scrollOffset = scrollLeft;\n\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n            // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                scrollOffset = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._onScrollVertical = function (event) {\n        var _event$currentTarget2 = event.currentTarget,\n            clientHeight = _event$currentTarget2.clientHeight,\n            scrollHeight = _event$currentTarget2.scrollHeight,\n            scrollTop = _event$currentTarget2.scrollTop;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1, null);\n        });\n      };\n\n      return _this;\n    }\n\n    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps$1(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = List.prototype;\n\n    _proto.scrollTo = function scrollTo(scrollOffset) {\n      scrollOffset = Math.max(0, scrollOffset);\n      this.setState(function (prevState) {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(index, align) {\n      if (align === void 0) {\n        align = 'auto';\n      }\n\n      var _this$props2 = this.props,\n          itemCount = _this$props2.itemCount,\n          layout = _this$props2.layout;\n      var scrollOffset = this.state.scrollOffset;\n      index = Math.max(0, Math.min(index, itemCount - 1)); // The scrollbar size should be considered when scrolling an item into view, to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n      // This is an edge case for lists; normally they only scroll in the dominant direction.\n\n      var scrollbarSize = 0;\n\n      if (this._outerRef) {\n        var outerRef = this._outerRef;\n\n        if (layout === 'vertical') {\n          scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;\n        } else {\n          scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;\n        }\n      }\n\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps, scrollbarSize));\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          direction = _this$props3.direction,\n          initialScrollOffset = _this$props3.initialScrollOffset,\n          layout = _this$props3.layout;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$props4 = this.props,\n          direction = _this$props4.direction,\n          layout = _this$props4.layout;\n      var _this$state = this.state,\n          scrollOffset = _this$state.scrollOffset,\n          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n\n              default:\n                var clientWidth = outerRef.clientWidth,\n                    scrollWidth = outerRef.scrollWidth;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props5 = this.props,\n          children = _this$props5.children,\n          className = _this$props5.className,\n          direction = _this$props5.direction,\n          height = _this$props5.height,\n          innerRef = _this$props5.innerRef,\n          innerElementType = _this$props5.innerElementType,\n          innerTagName = _this$props5.innerTagName,\n          itemCount = _this$props5.itemCount,\n          itemData = _this$props5.itemData,\n          _this$props5$itemKey = _this$props5.itemKey,\n          itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey,\n          layout = _this$props5.layout,\n          outerElementType = _this$props5.outerElementType,\n          outerTagName = _this$props5.outerTagName,\n          style = _this$props5.style,\n          useIsScrolling = _this$props5.useIsScrolling,\n          width = _this$props5.width;\n      var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n\n      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n\n      var _this$_getRangeToRend = this._getRangeToRender(),\n          startIndex = _this$_getRangeToRend[0],\n          stopIndex = _this$_getRangeToRend[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(_index, itemData),\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(_index)\n          }));\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: isHorizontal ? '100%' : estimatedTotalSize,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: isHorizontal ? estimatedTotalSize : '100%'\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        var itemCount = this.props.itemCount;\n\n        if (itemCount > 0) {\n          var _this$_getRangeToRend2 = this._getRangeToRender(),\n              _overscanStartIndex = _this$_getRangeToRend2[0],\n              _overscanStopIndex = _this$_getRangeToRend2[1],\n              _visibleStartIndex = _this$_getRangeToRend2[2],\n              _visibleStopIndex = _this$_getRangeToRend2[3];\n\n          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        var _this$state2 = this.state,\n            _scrollDirection = _this$state2.scrollDirection,\n            _scrollOffset = _this$state2.scrollOffset,\n            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getRangeToRender = function _getRangeToRender() {\n      var _this$props6 = this.props,\n          itemCount = _this$props6.itemCount,\n          overscanCount = _this$props6.overscanCount;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollDirection = _this$state3.scrollDirection,\n          scrollOffset = _this$state3.scrollOffset;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return List;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _class;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nvar validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {\n  var children = _ref2.children,\n      direction = _ref2.direction,\n      height = _ref2.height,\n      layout = _ref2.layout,\n      innerTagName = _ref2.innerTagName,\n      outerTagName = _ref2.outerTagName,\n      width = _ref2.width;\n  var instance = _ref3.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n        devWarningsTagName$1.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    } // TODO Deprecate direction \"horizontal\"\n\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n        }\n\n        break;\n\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + (\"\\\"\" + layout + \"\\\" was specified.\"));\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\n\nvar getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {\n  var _ref = props,\n      itemSize = _ref.itemSize;\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n  var itemCount = props.itemCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {\n  var itemCount = _ref2.itemCount;\n  var itemMetadataMap = _ref3.itemMetadataMap,\n      estimatedItemSize = _ref3.estimatedItemSize,\n      lastMeasuredIndex = _ref3.lastMeasuredIndex;\n  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar VariableSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata$1(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    return instanceProps.itemMetadataMap[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    var direction = props.direction,\n        height = props.height,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size + scrollbarSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    return findNearestItem$1(props, instanceProps, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        itemCount = props.itemCount,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref4 = props,\n        estimatedItemSize = _ref4.estimatedItemSize;\n    var instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return index * columnWidth;\n  },\n  getColumnWidth: function getColumnWidth(_ref2, index) {\n    var columnWidth = _ref2.columnWidth;\n    return columnWidth;\n  },\n  getRowOffset: function getRowOffset(_ref3, index) {\n    var rowHeight = _ref3.rowHeight;\n    return index * rowHeight;\n  },\n  getRowHeight: function getRowHeight(_ref4, index) {\n    var rowHeight = _ref4.rowHeight;\n    return rowHeight;\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n    var rowCount = _ref5.rowCount,\n        rowHeight = _ref5.rowHeight;\n    return rowHeight * rowCount;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n    var columnCount = _ref6.columnCount,\n        columnWidth = _ref6.columnWidth;\n    return columnWidth * columnCount;\n  },\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n    var columnCount = _ref7.columnCount,\n        columnWidth = _ref7.columnWidth,\n        width = _ref7.width;\n    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);\n    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n    var rowHeight = _ref8.rowHeight,\n        height = _ref8.height,\n        rowCount = _ref8.rowCount;\n    var lastRowOffset = Math.max(0, rowCount * rowHeight - height);\n    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n    var columnWidth = _ref9.columnWidth,\n        columnCount = _ref9.columnCount;\n    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n    var columnWidth = _ref10.columnWidth,\n        columnCount = _ref10.columnCount,\n        width = _ref10.width;\n    var left = startIndex * columnWidth;\n    var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n    var rowHeight = _ref11.rowHeight,\n        rowCount = _ref11.rowCount;\n    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n    var rowHeight = _ref12.rowHeight,\n        rowCount = _ref12.rowCount,\n        height = _ref12.height;\n    var top = startIndex * rowHeight;\n    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref13) {\n    var columnWidth = _ref13.columnWidth,\n        rowHeight = _ref13.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2, index) {\n    var itemSize = _ref2.itemSize;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var itemCount = _ref3.itemCount,\n        itemSize = _ref3.itemSize;\n    return itemSize * itemCount;\n  },\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    var direction = _ref4.direction,\n        height = _ref4.height,\n        itemCount = _ref4.itemCount,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var lastItemOffset = Math.max(0, itemCount * itemSize - size);\n    var maxOffset = Math.min(lastItemOffset, index * itemSize);\n    var minOffset = Math.max(0, index * itemSize - size + itemSize + scrollbarSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        {\n          // \"Centered\" offset is usually the average of the min and max.\n          // But near the edges of the list, this doesn't hold true.\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0; // near the beginning\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset; // near the end\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var itemCount = _ref5.itemCount,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var direction = _ref6.direction,\n        height = _ref6.height,\n        itemCount = _ref6.itemCount,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var offset = startIndex * itemSize;\n    var size = isHorizontal ? width : height;\n    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref7) {\n    var itemSize = _ref7.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar _excluded = [\"style\"],\n    _excluded2 = [\"style\"];\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\n\nfunction areEqual(prevProps, nextProps) {\n  var prevStyle = prevProps.style,\n      prevRest = _objectWithoutPropertiesLoose(prevProps, _excluded);\n\n  var nextStyle = nextProps.style,\n      nextRest = _objectWithoutPropertiesLoose(nextProps, _excluded2);\n\n  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n\nexport { FixedSizeGrid, FixedSizeList, VariableSizeGrid, VariableSizeList, areEqual, shouldComponentUpdate };\n//# sourceMappingURL=index.esm.js.map\n","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}","import { VariableSizeGrid as OriginalVariableSizeGrid } from \"react-window\";\r\n\r\nexport class VariableSizeGrid extends OriginalVariableSizeGrid {}\r\n\r\nexport default VariableSizeGrid","import { Align, VariableSizeGridProps } from \"react-window\";\r\nimport { columnGetter, Grid, InstanceProps, ItemMetadata, ItemMetadataMap, itemSizeGetter, ItemType } from \"./grid\";\r\n\r\nexport interface IGridProps<RecordType extends Record<any, any> = any> extends VariableSizeGridProps<readonly RecordType[]> {\r\n    rerenderFixedColumnOnHorizontalScroll?: boolean,\r\n    scrollbarSize?: number,\r\n    itemData: readonly RecordType[],\r\n    columnGetter: columnGetter<RecordType>,\r\n}\r\n\r\nexport const getItemMetadata = <TRecord extends Record<any, any> = any,>(\r\n    itemType: ItemType,\r\n    props: Grid<TRecord>['props'],\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n): ItemMetadata => {\r\n\r\n    let itemMetadataMap: ItemMetadataMap, itemSize: itemSizeGetter, lastMeasuredIndex: number;\r\n\r\n    if (itemType === 'column') {\r\n        itemMetadataMap = instanceProps.columnMetadataMap;\r\n        itemSize = props.columnWidth;\r\n        lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\r\n    } else {\r\n        itemMetadataMap = instanceProps.rowMetadataMap;\r\n        itemSize = props.rowHeight;\r\n        lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\r\n    }\r\n  \r\n    if (index > lastMeasuredIndex) {\r\n\r\n        let offset = 0;\r\n\r\n        if (lastMeasuredIndex >= 0) {\r\n            const itemMetadata = itemMetadataMap[lastMeasuredIndex];\r\n            offset = itemMetadata.offset + itemMetadata.size;\r\n        }\r\n  \r\n        for (let i = lastMeasuredIndex + 1; i <= index; i++) {\r\n\r\n            let size = itemSize(i);\r\n  \r\n            itemMetadataMap[i] = {\r\n                offset,\r\n                size,\r\n            };\r\n  \r\n            offset += size;\r\n        }\r\n  \r\n        if (itemType === 'column') {\r\n            instanceProps.lastMeasuredColumnIndex = index;\r\n        } else {\r\n            instanceProps.lastMeasuredRowIndex = index;\r\n        }\r\n    }\r\n\r\n    return itemMetadataMap[index];\r\n}\r\n\r\nexport const getEstimatedTotalHeight = <TRecord extends Record<any, any> = any,>(\r\n    { rowCount }: Grid<TRecord>['props'],\r\n    { rowMetadataMap, estimatedRowHeight, lastMeasuredRowIndex }: InstanceProps\r\n) => {\r\n    let totalSizeOfMeasuredRows = 0;\r\n  \r\n    // Edge case check for when the number of items decreases while a scroll is in progress.\r\n    // https://github.com/bvaughn/react-window/pull/138\r\n    if (lastMeasuredRowIndex >= rowCount) {\r\n        lastMeasuredRowIndex = rowCount - 1;\r\n    }\r\n  \r\n    if (lastMeasuredRowIndex >= 0) {\r\n        const itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\r\n        totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\r\n    }\r\n  \r\n    const numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\r\n    const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\r\n  \r\n    return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\r\n};\r\n\r\nexport const getEstimatedTotalWidth = <TRecord extends Record<any, any> = any,>(\r\n    { columnCount }: Grid<TRecord>['props'],\r\n    {\r\n        columnMetadataMap,\r\n        estimatedColumnWidth,\r\n        lastMeasuredColumnIndex,\r\n    }: InstanceProps\r\n) => {\r\n    let totalSizeOfMeasuredRows = 0;\r\n  \r\n    // Edge case check for when the number of items decreases while a scroll is in progress.\r\n    // https://github.com/bvaughn/react-window/pull/138\r\n    if (lastMeasuredColumnIndex >= columnCount) {\r\n        lastMeasuredColumnIndex = columnCount - 1;\r\n    }\r\n  \r\n    if (lastMeasuredColumnIndex >= 0) {\r\n        const itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\r\n        totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\r\n    }\r\n  \r\n    const numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\r\n    const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\r\n\r\n    return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\r\n};\r\n\r\nexport const getOffsetForIndexAndAlignment = <TRecord extends Record<any, any> = any,>(\r\n    itemType: ItemType,\r\n    props: Grid<TRecord>['props'],\r\n    index: number,\r\n    align: Align | undefined,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number,\r\n    sumOfLeftFixedColumnsWidth: number,\r\n    sumOfRightFixedColumnsWidth: number,\r\n  ): number => {\r\n\r\n    const leftOffset = itemType === 'column' ? sumOfLeftFixedColumnsWidth : 0;\r\n    const rightOffset = itemType === 'column' ? sumOfRightFixedColumnsWidth : 0;\r\n    const size = itemType === 'column' ? props.width : props.height;\r\n    const itemMetadata = getItemMetadata(itemType, props, index, instanceProps);\r\n\r\n    // Get estimated total size after ItemMetadata is computed,\r\n    // To ensure it reflects actual measurements instead of just estimates.\r\n    const estimatedTotalSize =\r\n        itemType === 'column'\r\n            ? getEstimatedTotalWidth(props, instanceProps)\r\n            : getEstimatedTotalHeight(props, instanceProps);\r\n\r\n    const maxOffset = Math.max(\r\n        0,\r\n        Math.min(estimatedTotalSize - size + leftOffset, itemMetadata.offset - leftOffset)\r\n    );\r\n\r\n    const minOffset = Math.max(\r\n        0,\r\n        itemMetadata.offset + itemMetadata.size - size + rightOffset + scrollbarSize\r\n    );\r\n\r\n    if (align === 'smart') {\r\n\r\n        if (\r\n            scrollOffset >= minOffset - size &&\r\n            scrollOffset <= maxOffset + size\r\n        ) {\r\n            align = 'auto';\r\n        } else {\r\n            align = 'center';\r\n        }\r\n    }\r\n\r\n    switch (align) {\r\n        case 'start':\r\n            return maxOffset;\r\n        case 'end':\r\n            return minOffset;\r\n        case 'center':\r\n            return Math.round(minOffset + (maxOffset - minOffset) / 2);\r\n        case 'auto':\r\n        default:\r\n            if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\r\n                return scrollOffset;\r\n            } else if (minOffset > maxOffset) {\r\n                // Because we only take into account the scrollbar size when calculating minOffset\r\n                // this value can be larger than maxOffset when at the end of the list\r\n                return minOffset;\r\n            } else if (scrollOffset < minOffset) {\r\n                return minOffset;\r\n            } else {\r\n                return maxOffset;\r\n            }\r\n    }\r\n}\r\n\r\nexport const getOffsetForColumnAndAlignment = <TRecord extends Record<any, any> = any,>(\r\n    props: Grid<TRecord>['props'],\r\n    index: number,\r\n    align: Align | undefined,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number,\r\n    sumOfLeftFixedColumnsWidth: number,\r\n    sumOfRightFixedColumnsWidth: number,\r\n): number =>\r\n    getOffsetForIndexAndAlignment(\r\n        'column',\r\n        props,\r\n        index,\r\n        align,\r\n        scrollOffset,\r\n        instanceProps,\r\n        scrollbarSize,\r\n        sumOfLeftFixedColumnsWidth,\r\n        sumOfRightFixedColumnsWidth\r\n    )\r\n\r\nexport const getOffsetForRowAndAlignment = <TRecord extends Record<any, any> = any,>(\r\n    props: Grid<TRecord>['props'],\r\n    index: number,\r\n    align: Align | undefined,\r\n    scrollOffset: number,\r\n    instanceProps: InstanceProps,\r\n    scrollbarSize: number,\r\n    sumOfLeftFixedColumnsWidth: number,\r\n    sumOfRightFixedColumnsWidth: number,\r\n): number =>\r\n    getOffsetForIndexAndAlignment(\r\n        'row',\r\n        props,\r\n        index,\r\n        align,\r\n        scrollOffset,\r\n        instanceProps,\r\n        scrollbarSize,\r\n        sumOfLeftFixedColumnsWidth,\r\n        sumOfRightFixedColumnsWidth\r\n    )\r\n\r\nexport const getRowOffset = <TRecord extends Record<any, any> = any,>(\r\n    props: Grid<TRecord>['props'],\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n): number => getItemMetadata('row', props, index, instanceProps).offset;\r\n\r\nexport const getRowHeightOrCalculate = <TRecord extends Record<any, any> = any,>(\r\n    props: Grid<TRecord>['props'],\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n): number => getItemMetadata('row', props, index, instanceProps).size;\r\n\r\nexport const getRowHeight = <TRecord extends Record<any, any> = any,>(\r\n    props: Grid<TRecord>['props'],\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n): number => instanceProps.rowMetadataMap[index].size;\r\n\r\nexport const getColumnWidth = <TRecord extends Record<any, any> = any,>(\r\n    props: Grid<TRecord>['props'],\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n): number => instanceProps.columnMetadataMap[index].size;\r\n\r\nexport const getColumnWidthOrCalculate = <TRecord extends Record<any, any> = any,>(\r\n    props: Grid<TRecord>['props'],\r\n    index: number,\r\n    instanceProps: InstanceProps\r\n): number => getItemMetadata('column', props, index, instanceProps).size;","import React, { createElement } from \"react\";\r\nimport { Align, VariableSizeGridProps, GridOnScrollProps } from \"react-window\";\r\nimport { getScrollbarSize } from \"./dom-helpers\";\r\nimport { classNames, isFunction } from \"./helpers\";\r\nimport { defaultItemKey } from \"./cell\";\r\nimport { VariableSizeGrid } from './react-window-grid.js';\r\nimport { ColumnType } from \"./table\";\r\nimport { getEstimatedTotalHeight, getEstimatedTotalWidth, getOffsetForColumnAndAlignment, getOffsetForRowAndAlignment } from './grid-helpers';\r\n\r\nexport type columnGetter<TRecord extends Record<any, any> = any> = (index: number) => ColumnType<TRecord>;\r\nexport type itemSizeGetter = (index: number) => number;\r\nexport type ItemType = 'column' | 'row';\r\n\r\nexport type ScrollEvent = React.SyntheticEvent<ScrollEvent>;\r\n\r\nexport type ItemMetadata = {\r\n    offset: number,\r\n    size: number,\r\n}\r\n\r\nexport type ItemMetadataMap = { [index: number]: ItemMetadata }\r\n\r\nexport type InstanceProps = {\r\n    columnMetadataMap: ItemMetadataMap,\r\n    estimatedColumnWidth: number,\r\n    estimatedRowHeight: number,\r\n    lastMeasuredColumnIndex: number,\r\n    lastMeasuredRowIndex: number,\r\n    rowMetadataMap: ItemMetadataMap,\r\n}\r\n\r\nexport interface IItemStyle extends React.CSSProperties {\r\n    position: React.CSSProperties['position'],\r\n    left: number,\r\n    right: number,\r\n    top: number,\r\n    height: number,\r\n    width: number,\r\n}\r\n\r\nconst defaultRowClassName = \"virtial-grid-row\";\r\nconst defaultFixedRowClassName = \"fixed-virtial-grid-row-columns\";\r\nconst defaultFixedRowLeftColumnsClassName = \"fixed-virtial-grid-row-left-columns\";\r\nconst defaultFixedRowRightColumnsClassName = \"fixed-virtial-grid-row-right-columns\";\r\nconst defaultHasFixedLeftColumnClassName = \"has-fixed-left-column\";\r\nconst defaultHasFixedRightColumnClassName = \"has-fixed-right-column\";\r\n\r\nexport type OnScrollProps = GridOnScrollProps;\r\nexport type OnScrollCallback = (props: OnScrollProps) => void;\r\n\r\nexport interface IGrid<RecordType extends Record<any, any> = any> extends Omit<VariableSizeGrid<readonly RecordType[]>, 'props' | 'state'> {\r\n    props: IGridProps<RecordType>;\r\n    state: Readonly<IGridState>;\r\n}\r\n\r\nexport interface IScrollToParams {\r\n    scrollLeft?: number | undefined;\r\n    scrollTop?: number | undefined;\r\n}\r\n\r\nexport interface IScrollToItemParams {\r\n    align?: Align | undefined;\r\n    columnIndex?: number | undefined;\r\n    rowIndex?: number | undefined;\r\n}\r\n\r\nexport interface IResetAfterIndicesParams {\r\n    columnIndex: number;\r\n    rowIndex: number;\r\n    shouldForceUpdate?: boolean | undefined;\r\n}\r\n\r\nexport interface IGridState {\r\n    isScrolling: boolean,\r\n    scrollTop: number,\r\n    scrollLeft: number,\r\n}\r\n\r\nexport interface IGridProps<RecordType extends Record<any, any> = any> extends VariableSizeGridProps<readonly RecordType[]> {\r\n    rerenderFixedColumnOnHorizontalScroll?: boolean,\r\n    rowClassName?: (record: RecordType, index: number) => string,\r\n    onRow?: (record: RecordType, index: number) => React.HTMLAttributes<HTMLDivElement>;\r\n    rowKey?: string | ((record: RecordType) => string), \r\n    scrollbarSize?: number,\r\n    itemData: readonly RecordType[],\r\n    columnGetter: columnGetter<RecordType>,\r\n}\r\n\r\nexport class Grid<RecordType extends Record<any, any> = any> extends VariableSizeGrid<RecordType> {\r\n\r\n    private _leftFixedColumnsWidth = 0;\r\n    private _rightFixedColumnsWidth = 0;\r\n\r\n    private _firstUnFixedColumn = 0;\r\n\r\n    /** может быть равен <b>props.columnCount</b>, когда нет фиксированных колонок справо */\r\n    private _firstRightFixedColumn = 0;\r\n\r\n    private _lastFixedRenderedContent: Record<number | string, [React.ReactElement[], React.ReactElement[]]> | undefined;\r\n    private _lastFixedRenderedRowStartIndex: number | undefined;\r\n    private _lastFixedRenderedRowStopIndex: number | undefined\r\n\r\n    constructor(props: IGridProps<RecordType>) {\r\n        super(props);\r\n        this._updateFixedColumnsVars();\r\n    }\r\n\r\n    private _updateFixedColumnsVars() {\r\n\r\n        const { columnCount, columnGetter, columnWidth } = this.props;\r\n\r\n        this._firstUnFixedColumn = 0;\r\n        this._firstRightFixedColumn = columnCount;\r\n        this._leftFixedColumnsWidth = 0;\r\n        this._rightFixedColumnsWidth = 0;\r\n\r\n        this._lastFixedRenderedContent = undefined;\r\n        this._lastFixedRenderedRowStartIndex = undefined;\r\n        this._lastFixedRenderedRowStopIndex = undefined;\r\n\r\n        for (let columnIndex = 0; columnIndex < columnCount; columnIndex++) {\r\n\r\n            let column = columnGetter(columnIndex);\r\n\r\n            if (column.fixed === 'left' || column.fixed === true) {\r\n                this._firstUnFixedColumn++;\r\n                this._leftFixedColumnsWidth += columnWidth(columnIndex);\r\n                continue;\r\n            }\r\n\r\n            break;\r\n        }\r\n\r\n        for (let columnIndex = columnCount - 1; columnIndex > -1; columnIndex--) {\r\n\r\n            let column = columnGetter(columnIndex);\r\n\r\n            if (column.fixed === 'right') {\r\n                this._firstRightFixedColumn--;\r\n                this._rightFixedColumnsWidth += columnWidth(columnIndex);\r\n                continue;\r\n            }\r\n\r\n            break;\r\n        }\r\n    }\r\n\r\n    _renderFixedColumns(rowStartIndex: number, rowStopIndex: number, update: boolean = false) {\r\n\r\n        const { rerenderFixedColumnOnHorizontalScroll, columnWidth, rowHeight } = this.props;\r\n\r\n        if(rerenderFixedColumnOnHorizontalScroll === false\r\n        && update === false\r\n        && this._lastFixedRenderedRowStartIndex === rowStartIndex\r\n        && this._lastFixedRenderedRowStopIndex === rowStopIndex\r\n        && this._lastFixedRenderedContent) {\r\n            return this._lastFixedRenderedContent;\r\n        }\r\n        \r\n        const { children, itemData, columnCount, useIsScrolling, itemKey = defaultItemKey } = this.props;\r\n        const { isScrolling } = this.state;\r\n\r\n        const rows: typeof this._lastFixedRenderedContent = {};\r\n        const shownRowsCount = rowStopIndex - rowStartIndex + 1;\r\n    \r\n        // нет смысла рендерить скрытые колонки\r\n        if(this._leftFixedColumnsWidth > 0\r\n        || this._rightFixedColumnsWidth > 0) {\r\n    \r\n            for (\r\n                let visibleRowIndex = 0;\r\n                visibleRowIndex < shownRowsCount;\r\n                visibleRowIndex++\r\n            ) {\r\n                const rowLeftColumns: React.ReactElement[] = [];\r\n                const rowRightColumns: React.ReactElement[] = [];\r\n                const rowIndex = rowStartIndex + visibleRowIndex;\r\n                const height = rowHeight(rowIndex);\r\n\r\n                const renderFixedColumn = (columnIndex: number) => {\r\n\r\n                    const width = columnWidth(columnIndex);\r\n                    return createElement(children, {\r\n                        key: itemKey({ columnIndex, data: itemData, rowIndex }),\r\n                        rowIndex,\r\n                        columnIndex,\r\n                        data: itemData,\r\n                        isScrolling: useIsScrolling ? isScrolling : undefined,\r\n                        style: {\r\n                            width: width,\r\n                            height: height,\r\n                        }\r\n                    });\r\n                }\r\n\r\n                for (\r\n                    let columnIndex = 0;\r\n                    columnIndex < this._firstUnFixedColumn;\r\n                    columnIndex++\r\n                ) {\r\n                    const item = renderFixedColumn(columnIndex);\r\n                    rowLeftColumns.push(item);\r\n                }\r\n\r\n                for (\r\n                    let columnIndex = this._firstRightFixedColumn;\r\n                    columnIndex < columnCount;\r\n                    columnIndex++\r\n                ) {\r\n                    const item = renderFixedColumn(columnIndex);\r\n                    rowRightColumns.push(item);\r\n                }\r\n    \r\n                if (rowLeftColumns.length > 0 || rowRightColumns.length > 0) {\r\n                    rows[rowIndex] = [rowLeftColumns, rowRightColumns];\r\n                }\r\n            }\r\n        }\r\n    \r\n        this._lastFixedRenderedRowStartIndex = rowStartIndex;\r\n        this._lastFixedRenderedRowStopIndex = rowStopIndex;\r\n        this._lastFixedRenderedContent = rows;\r\n\r\n        return rows;\r\n    }\r\n\r\n    scrollToItem({ align, rowIndex, columnIndex }: IScrollToItemParams) {\r\n\r\n        const { columnCount, height, rowCount, width } = this.props;\r\n        const { scrollLeft, scrollTop } = this.state;\r\n        const { scrollbarSize = getScrollbarSize() } = this.props;\r\n    \r\n        if (columnIndex !== undefined) {\r\n            columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\r\n        }\r\n    \r\n        if (rowIndex !== undefined) {\r\n            rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\r\n        }\r\n    \r\n        const estimatedTotalHeight = getEstimatedTotalHeight(\r\n            this.props,\r\n            this._instanceProps\r\n        );\r\n    \r\n        const estimatedTotalWidth = getEstimatedTotalWidth(\r\n            this.props,\r\n            this._instanceProps\r\n        );\r\n    \r\n        // The scrollbar size should be considered when scrolling an item into view,\r\n        // to ensure it's fully visible.\r\n        // But we only need to account for its size when it's actually visible.\r\n        const horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\r\n        const verticalScrollbarSize   = estimatedTotalHeight > height ? scrollbarSize : 0;\r\n    \r\n        this.scrollTo({\r\n            scrollLeft:\r\n                columnIndex !== undefined\r\n                    ? getOffsetForColumnAndAlignment(\r\n                        this.props,\r\n                        columnIndex,\r\n                        align,\r\n                        scrollLeft,\r\n                        this._instanceProps,\r\n                        verticalScrollbarSize,\r\n                        this._leftFixedColumnsWidth,\r\n                        this._rightFixedColumnsWidth,\r\n                    )\r\n                    : scrollLeft,\r\n                scrollTop:\r\n                    rowIndex !== undefined\r\n                        ? getOffsetForRowAndAlignment(\r\n                            this.props,\r\n                            rowIndex,\r\n                            align,\r\n                            scrollTop,\r\n                            this._instanceProps,\r\n                            horizontalScrollbarSize,\r\n                            this._leftFixedColumnsWidth,\r\n                            this._rightFixedColumnsWidth,\r\n                        )\r\n                        : scrollTop,\r\n        });\r\n    }\r\n\r\n    render() {\r\n\r\n        const {\r\n            className,\r\n            columnCount,\r\n            height,\r\n            innerRef,\r\n            innerElementType,\r\n            innerTagName,\r\n            outerElementType,\r\n            outerTagName,\r\n            rowCount,\r\n            direction,\r\n            style,\r\n            width,\r\n\r\n            useIsScrolling,\r\n            itemData,\r\n            rowClassName,\r\n            onRow,\r\n            children,\r\n            rowKey,\r\n            itemKey = defaultItemKey,\r\n\r\n        } = this.props;\r\n\r\n        const { isScrolling } = this.state;\r\n    \r\n        const rowsColumns: Record<number | string, Record<number | string, React.ReactElement>> = {};\r\n        const rowsElementProps: Record<number | string, React.HTMLAttributes<HTMLDivElement> & { key: string }> = {};\r\n\r\n        let rowsFixedColumns: typeof this._lastFixedRenderedContent;\r\n\r\n        if(columnCount > 0\r\n        && rowCount > 0) {\r\n\r\n            const [columnStartIndex, columnStopIndex, ] = this._getHorizontalRangeToRender();\r\n            const [rowStartIndex, rowStopIndex] = this._getVerticalRangeToRender();\r\n\r\n            rowsFixedColumns = this._renderFixedColumns(rowStartIndex, rowStopIndex);\r\n\r\n            for (\r\n                let rowIndex = rowStartIndex;\r\n                rowIndex <= rowStopIndex;\r\n                rowIndex++\r\n            ) {\r\n                const record = itemData[rowIndex];\r\n                const className = rowClassName\r\n                                ? rowClassName(record, rowIndex)\r\n                                : undefined;\r\n                \r\n                const divProps = onRow\r\n                               ? onRow(record, rowIndex)\r\n                               : undefined;\r\n            \r\n                const key = isFunction(rowKey)\r\n                          ? rowKey(record)\r\n                          : rowKey ?? `${rowIndex}`;\r\n                \r\n                const firstItemStyle = this._getItemStyle(rowIndex, this._firstUnFixedColumn);\r\n                const firstUnFixedColumn = this._firstUnFixedColumn;\r\n                const firstRightFixedColumn = this._firstRightFixedColumn;\r\n                const rowColumns: Record<number, React.ReactElement> = [];\r\n\r\n                for (\r\n                    let columnIndex = columnStartIndex;\r\n                    columnIndex <= columnStopIndex;\r\n                    columnIndex++\r\n                ) {\r\n                    \r\n                    if(columnIndex < firstUnFixedColumn\r\n                    || columnIndex > firstRightFixedColumn - 1) {\r\n                        continue;\r\n                    }\r\n            \r\n                    const key = itemKey({ columnIndex, data: itemData, rowIndex });\r\n                    const style = this._getItemStyle(rowIndex, columnIndex);\r\n\r\n                    rowColumns[columnIndex] = createElement(children, {\r\n                        columnIndex,\r\n                        data: itemData,\r\n                        isScrolling: useIsScrolling ? isScrolling : undefined,\r\n                        key: key,\r\n                        rowIndex,\r\n                        style: style,\r\n                    });\r\n                }\r\n                \r\n                rowsColumns[rowIndex] = rowColumns;\r\n                rowsElementProps[rowIndex] = {\r\n                    ...divProps,\r\n                    key: key,\r\n                    style: {\r\n                        ...divProps?.style,\r\n                        top: firstItemStyle.top\r\n                    },\r\n                    className: classNames(\r\n                        defaultRowClassName,\r\n                        className,\r\n                        divProps?.className\r\n                    )\r\n                }\r\n            }\r\n        }\r\n    \r\n        // Read this value AFTER items have been created,\r\n        // So their actual sizes (if variable) are taken into consideration.\r\n        const estimatedTotalHeight = getEstimatedTotalHeight(\r\n            this.props,\r\n            this._instanceProps\r\n        );\r\n        const estimatedTotalWidth = getEstimatedTotalWidth(\r\n            this.props,\r\n            this._instanceProps\r\n        );\r\n\r\n        const rows = Object.entries(rowsElementProps).map(([rowIndex, props]) => {\r\n            \r\n            const { top, left } = props.style || {};\r\n            const rowFixedColumns = rowsFixedColumns ? rowsFixedColumns[rowIndex] : [];\r\n            const fixedLeftColumns = rowFixedColumns[0];\r\n            const fixedRightColumns = rowFixedColumns[1];\r\n            const columns = Object.values(rowsColumns[rowIndex]);\r\n\r\n            return (\r\n                <div\r\n                    {...props}\r\n                >\r\n                    {columns}\r\n                    <div\r\n                        className={defaultFixedRowClassName}\r\n                        style={{\r\n                            top: top,\r\n                            left: left,\r\n                            width: estimatedTotalWidth\r\n                        }}\r\n                    >\r\n                        {fixedLeftColumns && fixedLeftColumns.length > 0 &&\r\n                        <div className={defaultFixedRowLeftColumnsClassName}>\r\n                            {fixedLeftColumns}\r\n                        </div>}\r\n                        {fixedRightColumns && fixedRightColumns.length > 0 &&\r\n                        <div className={defaultFixedRowRightColumnsClassName}>\r\n                            {fixedRightColumns}\r\n                        </div>}\r\n                    </div>\r\n                </div>\r\n            );\r\n        });\r\n\r\n        const hasFixedLeftColumn  = this._leftFixedColumnsWidth > 0;\r\n        const hasFixedRightColumn = this._rightFixedColumnsWidth > 0;\r\n\r\n        return createElement(\r\n            outerElementType || outerTagName || 'div',\r\n            {\r\n                className: classNames(className, {\r\n                    [defaultHasFixedLeftColumnClassName]: hasFixedLeftColumn,\r\n                    [defaultHasFixedRightColumnClassName]: hasFixedRightColumn\r\n                }),\r\n                onScroll: this._onScroll,\r\n                ref: this._outerRefSetter,\r\n                style: {\r\n                    position: 'relative',\r\n                    height,\r\n                    width,\r\n                    overflow: 'auto',\r\n                    WebkitOverflowScrolling: 'touch',\r\n                    willChange: 'transform',\r\n                    direction,\r\n                    ...style,\r\n                },\r\n            },\r\n            createElement(innerElementType || innerTagName || 'div', {\r\n                children: rows,\r\n                ref: innerRef,\r\n                style: {\r\n                    height: estimatedTotalHeight,\r\n                    pointerEvents: isScrolling ? 'none' : undefined,\r\n                    width: estimatedTotalWidth,\r\n                },\r\n            })\r\n        );\r\n    }\r\n\r\n    componentDidUpdate(prevProps: IGridProps<RecordType>, prevState: IGridState, snapshot: any): void {\r\n\r\n        if(prevProps.columnGetter !== this.props.columnGetter\r\n        || prevProps.columnCount !== this.props.columnCount\r\n        || prevProps.columnWidth !== this.props.columnWidth) {\r\n            this._updateFixedColumnsVars();\r\n        }\r\n\r\n        // @ts-ignore\r\n        super.componentDidUpdate(prevProps, prevState, snapshot);\r\n    }\r\n}","import React, { Ref, useEffect } from 'react';\r\nimport { ConfigProvider, Empty, Table, TableProps, TableColumnType as AntdTableColumnType } from 'antd';\r\nimport { useCallback, useMemo, useRef, useState } from 'react';\r\nimport { Grid, OnScrollCallback, OnScrollProps } from './grid';\r\nimport { assignRef, classNames, isFunction, refSetter, sumColumnWidths, sumRowsHeights } from './helpers';\r\nimport { GridChildComponentProps, MemonableVirtualTableCell } from './cell';\r\nimport { TableComponents } from 'rc-table/lib/interface';\r\n\r\nimport './style.css';\r\n\r\nexport interface InfoRef {\r\n    scrollLeft: number;\r\n}\r\n\r\nexport interface Info {\r\n    scrollbarSize: number;\r\n    ref: React.Ref<InfoRef>;\r\n    onScroll: (info: {\r\n        currentTarget?: HTMLElement;\r\n        scrollLeft?: number;\r\n    }) => void;\r\n}\r\n\r\nexport interface ScrollViewSize {\r\n    x: number,\r\n    y: number\r\n}\r\n\r\nexport interface ScrollConfig extends ScrollViewSize {\r\n    scrollToFirstRowOnChange?: boolean;\r\n}\r\n\r\nexport interface ColumnType<RecordType extends Record<any, any> = any> extends Omit<AntdTableColumnType<RecordType>, \"width\" | \"shouldCellUpdate\" | \"onCell\" | \"render\"> {\r\n    overlap?: number,\r\n    width: number,\r\n    onCell?: (data: RecordType | undefined, index?: number, isScrolling?: boolean) => React.HTMLAttributes<any> | React.TdHTMLAttributes<any>;\r\n    render?: (value: any, record: RecordType | undefined, index: number, isScrolling?: boolean) => React.ReactNode;\r\n    shouldCellUpdate?: (record: RecordType | undefined, prevRecord: RecordType | undefined, isScrolling?: boolean) => boolean;\r\n}\r\n\r\nexport type ColumnsType<RecordType extends Record<any, any> = any> = ColumnType<RecordType>[];\r\n\r\nexport type VirtualTableComponents<RecordType> = Omit<TableComponents<RecordType>, \"body\">;\r\n\r\nexport interface VirtualTableProps<RecordType extends Record<any, any>> extends Omit<TableProps<RecordType>, \"columns\" | \"scroll\" | \"components\"> {\r\n    components?: VirtualTableComponents<RecordType>,\r\n    gridRef?: React.Ref<Grid<RecordType>>,\r\n    outerGridRef?: React.Ref<HTMLElement>,\r\n    scroll: ScrollConfig,\r\n    columns: ColumnsType<RecordType>,\r\n    rowHeight: number | ((record: Readonly<RecordType>) => number),\r\n    rerenderFixedColumnOnHorizontalScroll?: boolean,\r\n    onScroll?: OnScrollCallback,\r\n}\r\n\r\nexport const VirtualTable = <RecordType extends Record<any, any>>(props: VirtualTableProps<RecordType> & { ref?: Ref<HTMLDivElement> }) => {\r\n\r\n    const {\r\n        ref,\r\n        dataSource,\r\n        className,\r\n        columns,\r\n        rowHeight,\r\n        scroll,\r\n        gridRef,\r\n        outerGridRef,\r\n        onScroll,\r\n        onChange,\r\n        components,\r\n        locale,\r\n        showHeader,\r\n        rerenderFixedColumnOnHorizontalScroll,\r\n        ...tableProps\r\n    } = props;\r\n\r\n    const tableRef = useRef<HTMLElement | null>(null);\r\n    const internalGridRef = useRef<Grid<RecordType> | null>(null);\r\n    const [connectObject] = useState<InfoRef>(() => {\r\n\r\n        return {\r\n\r\n            get scrollLeft() {\r\n\r\n                if (internalGridRef.current) {\r\n                    return internalGridRef.current?.state.scrollLeft;\r\n                }\r\n\r\n                return 0;\r\n            },\r\n\r\n            set scrollLeft(value: number) {\r\n\r\n                if (internalGridRef.current) {\r\n\r\n                    const currentScrollLeft = internalGridRef.current.state.scrollLeft;\r\n\r\n                    if(currentScrollLeft == value) {\r\n                        return;\r\n                    }\r\n\r\n                    internalGridRef.current.scrollTo({ scrollLeft: value });\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n    const fixStickyHeaderOffset = useCallback((tableWrap?: HTMLElement | null) => {\r\n\r\n        // Данная функция нужна для поддержки overlap свойства колонки\r\n        // Исправляем смещение для sticky колонок\r\n        // Так же исправим баг связанный с таблицей\r\n\r\n        if(showHeader === false || components?.header) {\r\n            return;\r\n        }\r\n\r\n        if(tableWrap) {\r\n\r\n            const header = tableWrap.querySelector<HTMLElement>(\".ant-table .ant-table-header\");\r\n\r\n            if (header) {\r\n\r\n                const headerCells = header.querySelectorAll<HTMLTableCellElement>(\".ant-table-thead .ant-table-cell\");\r\n\r\n                let totalWidth = 0;\r\n\r\n                for(let headerIndex = 0; headerIndex < headerCells.length; headerIndex++) {\r\n                    const cell = headerCells[headerIndex];\r\n                    const width = cell.getBoundingClientRect().width;\r\n                    totalWidth += width;\r\n                }\r\n\r\n                // TODO: Возможно пользователь задал свое значение, тут надо подумать...\r\n                header.style.maxWidth = `${totalWidth}px`;\r\n\r\n                let leftOffset = 0;\r\n                let rightOffset = 0;\r\n\r\n                for(let headerIndex = 0; headerIndex < headerCells.length; headerIndex++) {\r\n\r\n                    const cell = headerCells[headerIndex];\r\n\r\n                    if (cell.classList.contains(\"ant-table-cell-fix-left\")) {\r\n                        const width = cell.getBoundingClientRect().width;\r\n                        cell.style.left = `${leftOffset}px`;\r\n                        leftOffset += width;\r\n                        continue;\r\n                    }\r\n\r\n                    break;\r\n                }\r\n\r\n                for(let headerIndex = headerCells.length - 1; headerIndex > -1; headerIndex--) {\r\n\r\n                    const cell = headerCells[headerIndex];\r\n\r\n                    if (cell.classList.contains(\"ant-table-cell-fix-right\")) {\r\n                        const width = cell.getBoundingClientRect().width;\r\n                        cell.style.right = `${rightOffset}px`;\r\n                        rightOffset += width;\r\n                        continue;\r\n                    }\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        \r\n    }, [scroll.x, scroll.y, scroll.scrollToFirstRowOnChange, components?.header, showHeader]);\r\n\r\n    const reset = useCallback((columnIndex: number = 0, rowIndex: number = 0) => {\r\n\r\n        fixStickyHeaderOffset(tableRef.current);\r\n\r\n        if(scroll.scrollToFirstRowOnChange) {\r\n            connectObject.scrollLeft = 0;\r\n        }\r\n\r\n        internalGridRef.current?.resetAfterIndices({\r\n            columnIndex: columnIndex,\r\n            rowIndex: rowIndex,\r\n            shouldForceUpdate: true,\r\n        });\r\n\r\n    }, [scroll.scrollToFirstRowOnChange, connectObject, fixStickyHeaderOffset]);\r\n\r\n    const handleChange = useCallback<NonNullable<typeof onChange>>((pagination, filters, sorter, extra) => {\r\n\r\n        fixStickyHeaderOffset(tableRef.current);\r\n\r\n        if(onChange) {\r\n            onChange(pagination, filters, sorter, extra);\r\n        }\r\n\r\n        if(scroll.scrollToFirstRowOnChange) {\r\n\r\n            reset();\r\n        }\r\n\r\n    }, [scroll.scrollToFirstRowOnChange, onChange, reset, fixStickyHeaderOffset]);\r\n\r\n    const [normalizeColumns, normalizeIndexes, getColumn, cellRender] = useMemo(() => {\r\n\r\n        let blockBuffer = 0;\r\n\r\n        const normalizeColumns: typeof columns = [];\r\n        const normalizeIndexes: number[] = [];\r\n\r\n        columns.forEach((column, index) => {\r\n            \r\n            if(blockBuffer > 1) {\r\n                blockBuffer--;\r\n                return;\r\n            }\r\n\r\n            blockBuffer = column.overlap ?? 0;\r\n\r\n            normalizeColumns.push(column);\r\n            normalizeIndexes.push(index);\r\n        });\r\n\r\n        const getColumn = (index: number) => normalizeColumns[index];\r\n        const cellRender = (props: GridChildComponentProps<RecordType>) => {\r\n\r\n            const { columnIndex } = props;\r\n            const originalColumnIndex = normalizeIndexes[columnIndex];\r\n            const column = normalizeColumns[columnIndex];\r\n\r\n            return (\r\n                <MemonableVirtualTableCell\r\n                    {...props}\r\n                    originalColumnIndex={originalColumnIndex}\r\n                    column={column}\r\n                />\r\n            );\r\n        };\r\n\r\n        return [\r\n            normalizeColumns,\r\n            normalizeIndexes,\r\n            getColumn,\r\n            cellRender\r\n        ]; \r\n\r\n    }, [columns]);\r\n\r\n    const rowHeightGetterByRecord = useMemo(\r\n        () => isFunction(rowHeight) ? rowHeight : () => rowHeight,\r\n        [rowHeight]\r\n    );\r\n\r\n    const { renderEmpty } = React.useContext(ConfigProvider.ConfigContext);\r\n\r\n    const emptyNode = useMemo(() => {\r\n\r\n        const emptyText = (locale && locale.emptyText) || renderEmpty?.('Table') || (\r\n            <Empty\r\n                image={Empty.PRESENTED_IMAGE_SIMPLE}\r\n            />\r\n        );\r\n\r\n        const emptyNode = typeof emptyText === 'function'\r\n                        ? emptyText()\r\n                        : emptyText;\r\n\r\n        return (\r\n            <div className=\"virtual-grid-empty\">\r\n                {emptyNode}\r\n            </div>\r\n        )\r\n\r\n    }, [locale?.emptyText, renderEmpty]);\r\n\r\n    const bodyRender = useCallback((rawData: readonly RecordType[], info: Info) => {\r\n\r\n        const { ref, scrollbarSize, onScroll: tableOnScroll } = info;\r\n\r\n        fixStickyHeaderOffset(tableRef.current);\r\n        assignRef(connectObject, ref);\r\n\r\n        const rowHeightGetter = (index: number) => rowHeightGetterByRecord(rawData[index]);\r\n\r\n        const totalHeight = sumRowsHeights(rowHeightGetter, rawData, rawData.length - 1);\r\n\r\n        const columnWidthGetter = (index: number): number => {\r\n\r\n            const column = normalizeColumns[index];\r\n            const { width, overlap } = column;\r\n    \r\n            if(overlap && overlap > 0) {\r\n    \r\n                let blockedWidth = width;\r\n                let lastBlockedIndex = normalizeIndexes[index];\r\n    \r\n                for(let overlapIndex = 1; overlapIndex < overlap; overlapIndex++) {\r\n                    lastBlockedIndex++;\r\n                    blockedWidth += columns[lastBlockedIndex].width;\r\n                }\r\n                \r\n                return lastBlockedIndex === columns.length - 1\r\n                ? blockedWidth - scrollbarSize\r\n                : blockedWidth;\r\n            }\r\n    \r\n            return totalHeight >= scroll.y && index === normalizeColumns.length - 1\r\n            ? width - scrollbarSize\r\n            : width;\r\n        }\r\n\r\n        const totalWidth  = sumColumnWidths(columnWidthGetter, normalizeColumns.length - 1);\r\n\r\n        const handleScroll = (props: OnScrollProps) => {\r\n    \r\n            if(tableOnScroll) {\r\n                tableOnScroll({\r\n                    scrollLeft: props.scrollLeft\r\n                });\r\n            }\r\n\r\n            if(onScroll) {\r\n                onScroll(props);\r\n            }\r\n        }\r\n\r\n        const hasData = rawData.length > 0;\r\n        \r\n        return (\r\n            <div className=\"virtual-grid-wrap\">\r\n                {!hasData && emptyNode}\r\n                <Grid<RecordType>\r\n                    useIsScrolling\r\n                    ref={refSetter(gridRef)}\r\n                    outerRef={outerGridRef}\r\n                    className=\"virtual-grid\"\r\n                    rerenderFixedColumnOnHorizontalScroll={rerenderFixedColumnOnHorizontalScroll}\r\n                    estimatedColumnWidth={totalWidth / normalizeColumns.length}\r\n                    estimatedRowHeight={totalHeight / rawData.length}\r\n                    width={scroll.x}\r\n                    height={scroll.y}\r\n                    columnCount={normalizeColumns.length}\r\n                    rowCount={rawData.length}\r\n                    rowHeight={rowHeightGetter}\r\n                    columnWidth={columnWidthGetter}\r\n                    itemData={rawData}\r\n                    columnGetter={getColumn}\r\n                    onScroll={handleScroll}\r\n                >\r\n                    {cellRender}\r\n                </Grid>\r\n            </div>\r\n        );\r\n    }, [\r\n        \r\n    ]);\r\n\r\n    useEffect(\r\n        () => fixStickyHeaderOffset(tableRef.current),\r\n        [fixStickyHeaderOffset, columns, showHeader, components?.header]\r\n    );\r\n\r\n    return (\r\n        <Table<RecordType>\r\n            {...tableProps}\r\n            ref={(el) => {\r\n                assignRef(el, ref, tableRef);\r\n                fixStickyHeaderOffset(el);\r\n            }}\r\n            locale={locale}\r\n            showHeader={showHeader}\r\n            className={classNames(\"virtual-table\", className)}\r\n            columns={columns}\r\n            dataSource={dataSource}\r\n            scroll={scroll}\r\n            components={{\r\n                ...components,\r\n                body: bodyRender,\r\n            }}\r\n            onChange={handleChange}\r\n        />\r\n    );\r\n}\r\n\r\nexport default VirtualTable;"],"names":["size","getScrollbarSize","recalculate","div","document","createElement","style","width","height","overflow","body","appendChild","offsetWidth","clientWidth","removeChild","isFunction","value","toString","call","assignRef","refValue","refs","i","length","tmpRef","current","refSetter","ref","hasOwn","hasOwnProperty","classNames","args","classes","arguments","arg","argType","push","Array","isArray","inner","apply","Object","prototype","includes","key","join","fastDeepEqual","equal","a","b","constructor","keys","RegExp","source","flags","valueOf","columnRowClassName","defaultItemKey","columnIndex","data","rowIndex","MemonableVirtualTableCell","memo","props","column","originalColumnIndex","isScrolling","row","dataIndex","undefined","cellProps","onCell","render","content","React","className","prevProps","nextProps","shouldCellUpdate","prevRecord","_extends","assign","bind","target","this","_assertThisInitialized","self","ReferenceError","_setPrototypeOf","o","p","setPrototypeOf","__proto__","safeIsNaN","Number","isNaN","areInputsEqual","newInputs","lastInputs","first","second","memoizeOne","resultFn","isEqual","lastThis","lastResult","lastArgs","calledOnce","newArgs","_i","now","performance","Date","cancelTimeout","timeoutID","cancelAnimationFrame","id","cachedRTLResult","getRTLOffsetType","outerDiv","outerStyle","direction","innerDiv","innerStyle","scrollLeft","IS_SCROLLING_DEBOUNCE_INTERVAL","_ref","devWarningsOverscanCount","devWarningsOverscanRowsColumnsCount","devWarningsTagName","createGridComponent","_ref2","_class","getColumnOffset","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getColumnWidth","getEstimatedTotalHeight","getEstimatedTotalWidth","getOffsetForColumnAndAlignment","getOffsetForRowAndAlignment","getRowHeight","getRowOffset","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","_PureComponent","subClass","superClass","Grid","_this","_instanceProps","_resetIsScrollingTimeoutId","_outerRef","state","instance","horizontalScrollDirection","initialScrollLeft","scrollTop","initialScrollTop","scrollUpdateWasRequested","verticalScrollDirection","_callOnItemsRendered","overscanColumnStartIndex","overscanColumnStopIndex","overscanRowStartIndex","overscanRowStopIndex","visibleColumnStartIndex","visibleColumnStopIndex","visibleRowStartIndex","visibleRowStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","_this$props","columnWidth","rowHeight","itemStyleCache","_getItemStyleCache","_offset","isRtl","position","left","right","top","_","__","___","_onScroll","event","_event$currentTarget","currentTarget","clientHeight","scrollHeight","scrollWidth","setState","prevState","calculatedScrollLeft","Math","max","min","calculatedScrollTop","_resetIsScrollingDebounced","_outerRefSetter","outerRef","callback","delay","start","_resetIsScrolling","requestAnimationFrame","tick","create","getDerivedStateFromProps","validateSharedProps","_proto","scrollTo","_ref3","scrollToItem","_ref4","_ref4$align","align","_this$props2","columnCount","rowCount","_this$state","scrollbarSize","estimatedTotalHeight","horizontalScrollbarSize","verticalScrollbarSize","componentDidMount","_this$props3","_callPropsCallbacks","componentDidUpdate","_this$state2","componentWillUnmount","_this$props4","children","innerRef","innerElementType","innerTagName","itemData","_this$props4$itemKey","itemKey","outerElementType","outerTagName","useIsScrolling","_this$_getHorizontalR","_getHorizontalRangeToRender","columnStartIndex","columnStopIndex","_this$_getVerticalRan","_getVerticalRangeToRender","rowStartIndex","rowStopIndex","items","_rowIndex","_columnIndex","estimatedTotalWidth","WebkitOverflowScrolling","willChange","pointerEvents","_this$props5","_this$_getHorizontalR2","_overscanColumnStartIndex","_overscanColumnStopIndex","_visibleColumnStartIndex","_visibleColumnStopIndex","_this$_getVerticalRan2","_overscanRowStartIndex","_overscanRowStopIndex","_visibleRowStartIndex","_visibleRowStopIndex","_this$state3","_horizontalScrollDirection","_scrollLeft","_scrollTop","_scrollUpdateWasRequested","_verticalScrollDirection","_this$props6","overscanColumnCount","overscanColumnsCount","overscanCount","_this$state4","overscanCountResolved","startIndex","stopIndex","overscanBackward","overscanForward","_this$props7","overscanRowCount","overscanRowsCount","_this$state5","PureComponent","defaultProps","process","env","NODE_ENV","window","WeakSet","_ref5","_ref6","has","add","console","warn","Error","rowMetadataMap","estimatedRowHeight","lastMeasuredRowIndex","totalSizeOfMeasuredRows","itemMetadata","offset","columnMetadataMap","estimatedColumnWidth","lastMeasuredColumnIndex","getItemMetadata","itemType","index","instanceProps","itemMetadataMap","itemSize","lastMeasuredIndex","findNearestItem","findNearestItemBinarySearch","findNearestItemExponentialSearch","high","low","middle","floor","currentOffset","itemCount","interval","getOffsetForIndexAndAlignment","scrollOffset","estimatedTotalSize","maxOffset","minOffset","round","VariableSizeGrid","resetAfterColumnIndex","shouldForceUpdate","resetAfterIndices","resetAfterRowIndex","_ref6$shouldForceUpda","forceUpdate","_ref7","OriginalVariableSizeGrid","sumOfLeftFixedColumnsWidth","sumOfRightFixedColumnsWidth","leftOffset","rightOffset","super","_leftFixedColumnsWidth","_rightFixedColumnsWidth","_firstUnFixedColumn","_firstRightFixedColumn","_updateFixedColumnsVars","columnGetter","_lastFixedRenderedContent","_lastFixedRenderedRowStartIndex","_lastFixedRenderedRowStopIndex","fixed","_renderFixedColumns","update","rerenderFixedColumnOnHorizontalScroll","rows","shownRowsCount","visibleRowIndex","rowLeftColumns","rowRightColumns","renderFixedColumn","item","rowClassName","onRow","rowKey","rowsColumns","rowsElementProps","rowsFixedColumns","record","divProps","firstItemStyle","firstUnFixedColumn","firstRightFixedColumn","rowColumns","entries","map","rowFixedColumns","fixedLeftColumns","fixedRightColumns","columns","values","hasFixedLeftColumn","hasFixedRightColumn","snapshot","VirtualTable","dataSource","scroll","gridRef","outerGridRef","onChange","components","locale","showHeader","tableProps","tableRef","useRef","internalGridRef","connectObject","useState","fixStickyHeaderOffset","useCallback","tableWrap","header","querySelector","headerCells","querySelectorAll","totalWidth","headerIndex","getBoundingClientRect","maxWidth","cell","classList","contains","x","y","scrollToFirstRowOnChange","reset","handleChange","pagination","filters","sorter","extra","normalizeColumns","normalizeIndexes","getColumn","cellRender","useMemo","blockBuffer","forEach","overlap","rowHeightGetterByRecord","renderEmpty","useContext","ConfigProvider","ConfigContext","emptyNode","emptyText","Empty","image","PRESENTED_IMAGE_SIMPLE","bodyRender","rawData","info","tableOnScroll","rowHeightGetter","totalHeight","sum","sumRowsHeights","columnWidthGetter","blockedWidth","lastBlockedIndex","overlapIndex","sumColumnWidths","hasData","useEffect","Table","el"],"mappings":"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","x_google_ignoreList":[2,4,5,6,7,8,9]}